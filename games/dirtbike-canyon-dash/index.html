<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Dirtbike Canyon Dash</title>
  <style>
    html, body { height: 100%; margin: 0; overflow: hidden; background: #0b1020; }
    #canvas { position: fixed; inset: 0; width: 100%; height: 100%; display: block; }
    #hud {
      position: fixed;
      top: 16px;
      left: 16px;
      color: #fff;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background: rgba(0,0,0,0.45);
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 10px;
      padding: 12px 14px;
      min-width: 220px;
      backdrop-filter: blur(8px);
    }
    #hud h3 { margin: 0 0 8px; font-size: 14px; letter-spacing: 0.5px; opacity: 0.9; }
    .row { display: flex; justify-content: space-between; gap: 10px; font-size: 13px; margin: 4px 0; }
    .label { opacity: 0.75; }
    .value { font-variant-numeric: tabular-nums; }

    #tip {
      position: fixed;
      bottom: 16px;
      left: 50%;
      transform: translateX(-50%);
      color: rgba(255,255,255,0.9);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background: rgba(0,0,0,0.35);
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 999px;
      padding: 10px 14px;
      backdrop-filter: blur(8px);
      font-size: 13px;
      white-space: nowrap;
    }

    #overlay {
      position: fixed;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      background: radial-gradient(1200px 700px at 50% 40%, rgba(255,140,0,0.20), rgba(0,0,0,0.85));
      color: #fff;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    }
    #card {
      width: min(520px, calc(100vw - 32px));
      background: rgba(0,0,0,0.55);
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 16px;
      padding: 18px;
      box-shadow: 0 24px 80px rgba(0,0,0,0.55);
      backdrop-filter: blur(12px);
      text-align: center;
    }
    #card h1 { margin: 8px 0 6px; font-size: 22px; }
    #card p { margin: 0 0 14px; opacity: 0.85; font-size: 13px; line-height: 1.4; }
    .btn {
      appearance: none;
      border: 0;
      border-radius: 10px;
      padding: 10px 14px;
      font-weight: 700;
      background: linear-gradient(135deg, #ff7a00, #ff2d55);
      color: #fff;
      cursor: pointer;
      box-shadow: 0 10px 30px rgba(255, 70, 80, 0.25);
    }
    .btn:active { transform: translateY(1px); }
    .small { font-size: 12px; opacity: 0.85; }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>

  <div id="hud" style="display:none;">
    <h3>DIRTBIKE CANYON DASH</h3>
    <div class="row"><span class="label">Score</span><span class="value" id="score">0</span></div>
    <div class="row"><span class="label">Best</span><span class="value" id="best">0</span></div>
    <div class="row"><span class="label">Speed</span><span class="value" id="speed">0</span></div>
  </div>

  <div id="tip" style="display:none;">Move: A/D or &larr;/&rarr;  |  Jump: Space / &uarr;  |  Restart on crash: automatic</div>

  <div id="overlay">
    <div id="card">
      <div class="small">Endless canyon sprint</div>
      <h1>Dirtbike Canyon Dash</h1>
      <p>Smooth 3D runner: auto-forward, dodge canyon hazards, and chase your best score. One crash restarts your run.</p>
      <button class="btn" id="start">Start</button>
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    let scene, camera, renderer, clock;
    let keys = {};

    const settings = {
      roadHalfWidth: 16,
      forwardSpeed: 1,
      forwardAccel: 12,
      lateralAccel: 55,
      lateralFriction: 10,
      lateralMaxSpeed: 40,
      cameraHeight: 6,
      cameraBack: 14,
      cameraLookAhead: -20,
      firstPerson: true,
      fpHeight: 1.45,
      fpForward: -1.9,
      fpLookAhead: -55,
      gravity: 22,
      jumpVelocity: 11.5,
      jumpClearance: 1.05,
      obstacleSpawnMinZ: -220,
      obstacleSpawnMaxZ: -60,
      obstacleSpawnInterval: 0.35,
      obstacleRadius: 1.25,
    };

    const state = {
      running: false,
      score: 0,
      best: 0,
      distance: 0,
      time: 0,
      nextSpawnIn: 0,
      restartIn: 0,
      shakeTime: 0,
      shakeStrength: 0,
    };

    const player = {
      mesh: null,
      x: 0,
      vx: 0,
      y: 0,
      vy: 0,
      grounded: true,
      jumpHeld: false,
      wasGrounded: true,
      radius: 1.1,
      visible: true,
      fpRig: null,
    };

    const world = {
      groundSegments: [],
      segmentLength: 40,
      segmentCount: 18,
      obstacles: [],
      flames: [],
      explosionParticles: [],
      dustParticles: [],
      explosionLight: null,
    };

    function clamp(v, min, max) { return Math.max(min, Math.min(max, v)); }

    function init() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x7fbef3);
      scene.fog = new THREE.Fog(0x7fbef3, 70, 340);

      camera = new THREE.PerspectiveCamera(80, window.innerWidth / window.innerHeight, 0.1, 800);

      renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('canvas'), antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;

      clock = new THREE.Clock();

      const hemi = new THREE.HemisphereLight(0xcfeaff, 0x5a3d2a, 0.9);
      scene.add(hemi);

      const sun = new THREE.DirectionalLight(0xfff2d2, 1.05);
      sun.position.set(40, 55, 25);
      sun.castShadow = true;
      sun.shadow.mapSize.set(2048, 2048);
      sun.shadow.camera.near = 1;
      sun.shadow.camera.far = 120;
      sun.shadow.camera.left = -60;
      sun.shadow.camera.right = 60;
      sun.shadow.camera.top = 60;
      sun.shadow.camera.bottom = -60;
      scene.add(sun);

      const fill = new THREE.DirectionalLight(0x88aaff, 0.25);
      fill.position.set(-35, 25, 10);
      scene.add(fill);

      createPlayer();
      createFirstPersonRig();
      createGround();

      scene.add(camera);

      window.addEventListener('resize', onResize);

      document.addEventListener('keydown', (e) => {
        keys[e.key.toLowerCase()] = true;
        if (['arrowup','arrowdown','arrowleft','arrowright',' '].includes(e.key.toLowerCase()) || ['ArrowUp','ArrowDown','ArrowLeft','ArrowRight',' '].includes(e.key)) {
          e.preventDefault();
        }
      }, { passive: false });

      document.addEventListener('keyup', (e) => {
        keys[e.key.toLowerCase()] = false;
      });

      state.best = Number(localStorage.getItem('dirtbike_best') || 0);
      document.getElementById('best').textContent = state.best;

      animate();
    }

    function onResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function createPlayer() {
      const group = new THREE.Group();

      const bodyMat = new THREE.MeshStandardMaterial({ color: 0xff7a00, roughness: 0.45, metalness: 0.15 });
      const darkMat = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.9, metalness: 0.05 });

      const frame = new THREE.Mesh(new THREE.BoxGeometry(1.2, 0.55, 3.0), bodyMat);
      frame.position.set(0, 1.0, 0);
      frame.castShadow = true;
      group.add(frame);

      const seat = new THREE.Mesh(new THREE.BoxGeometry(0.9, 0.25, 1.2), darkMat);
      seat.position.set(0, 1.35, -0.2);
      seat.castShadow = true;
      group.add(seat);

      const wheelGeo = new THREE.CylinderGeometry(0.55, 0.55, 0.35, 14);
      const w1 = new THREE.Mesh(wheelGeo, darkMat);
      w1.rotation.z = Math.PI / 2;
      w1.position.set(0, 0.6, 1.1);
      w1.castShadow = true;
      group.add(w1);

      const w2 = new THREE.Mesh(wheelGeo, darkMat);
      w2.rotation.z = Math.PI / 2;
      w2.position.set(0, 0.6, -1.2);
      w2.castShadow = true;
      group.add(w2);

      const flameGeo = new THREE.ConeGeometry(0.25, 0.9, 10);
      const flameMat = new THREE.MeshBasicMaterial({ color: 0xff5500, transparent: true, opacity: 0.0 });
      const flame = new THREE.Mesh(flameGeo, flameMat);
      flame.rotation.x = Math.PI;
      flame.position.set(0, 1.0, 1.6);
      group.add(flame);
      group.flame = flame;

      group.position.set(0, 0, 0);
      scene.add(group);

      player.mesh = group;
      player.x = 0;
      player.vx = 0;
      player.y = 0;
      player.vy = 0;
      player.grounded = true;
      player.jumpHeld = false;
      player.wasGrounded = true;
      player.visible = true;
    }

    function createFirstPersonRig() {
      const rig = new THREE.Group();
      const darkMat = new THREE.MeshStandardMaterial({ color: 0x141414, roughness: 0.95, metalness: 0.05 });
      const accentMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.65, metalness: 0.1 });
      const redMat = new THREE.MeshStandardMaterial({ color: 0xff3b30, roughness: 0.6, metalness: 0.12 });

      const bar = new THREE.Mesh(new THREE.CylinderGeometry(0.06, 0.06, 1.4, 10), darkMat);
      bar.rotation.z = Math.PI / 2;
      bar.position.set(0, 0.0, -0.65);
      rig.add(bar);

      const gripL = new THREE.Mesh(new THREE.CylinderGeometry(0.075, 0.075, 0.22, 10), darkMat);
      gripL.rotation.z = Math.PI / 2;
      gripL.position.set(-0.78, 0.0, -0.65);
      rig.add(gripL);
      const gripR = new THREE.Mesh(new THREE.CylinderGeometry(0.075, 0.075, 0.22, 10), darkMat);
      gripR.rotation.z = Math.PI / 2;
      gripR.position.set(0.78, 0.0, -0.65);
      rig.add(gripR);

      const stem = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.07, 0.35, 10), darkMat);
      stem.position.set(0, -0.15, -0.72);
      rig.add(stem);

      const plate = new THREE.Mesh(new THREE.BoxGeometry(0.35, 0.22, 0.1), accentMat);
      plate.position.set(0, 0.08, -0.95);
      rig.add(plate);

      const fender = new THREE.Mesh(new THREE.BoxGeometry(0.32, 0.06, 0.7), redMat);
      fender.position.set(0, -0.28, -1.35);
      rig.add(fender);

      const forkL = new THREE.Mesh(new THREE.CylinderGeometry(0.04, 0.045, 0.6, 10), darkMat);
      forkL.position.set(-0.18, -0.42, -1.2);
      rig.add(forkL);
      const forkR = new THREE.Mesh(new THREE.CylinderGeometry(0.04, 0.045, 0.6, 10), darkMat);
      forkR.position.set(0.18, -0.42, -1.2);
      rig.add(forkR);

      const wheel = new THREE.Mesh(new THREE.TorusGeometry(0.22, 0.06, 10, 18), darkMat);
      wheel.rotation.x = Math.PI / 2;
      wheel.position.set(0, -0.72, -1.55);
      rig.add(wheel);

      rig.position.set(0, -0.22, -0.1);
      camera.add(rig);
      player.fpRig = rig;
    }

    function createGround() {
      const roadMat = new THREE.MeshStandardMaterial({ color: 0x8a5a3a, roughness: 0.98, metalness: 0.0 });
      const stripeMat = new THREE.MeshStandardMaterial({ color: 0x3b2a1f, roughness: 1.0, metalness: 0.0 });
      const wallMat = new THREE.MeshStandardMaterial({ color: 0x8ea4b9, roughness: 0.95, metalness: 0.0, emissive: 0x0b1b2a, emissiveIntensity: 0.08 });

      for (let i = 0; i < world.segmentCount; i++) {
        const seg = new THREE.Group();

        const roadGeo = new THREE.PlaneGeometry(settings.roadHalfWidth * 2.4, world.segmentLength, 28, 22);
        const pos = roadGeo.attributes.position;
        for (let v = 0; v < pos.count; v++) {
          const x = pos.getX(v);
          const y = pos.getY(v);
          const nx = x * 0.12;
          const ny = y * 0.14;
          const bumps = Math.sin(nx * 2.2 + i * 0.35) * 0.10 + Math.cos(ny * 2.0 + i * 0.55) * 0.09;
          const grit = (Math.sin(nx * 7.0 + ny * 6.0 + i * 1.3) + Math.cos(nx * 6.5 - ny * 5.8 + i * 0.9)) * 0.03;
          const edge = Math.min(Math.abs(x) / (settings.roadHalfWidth * 1.2), 1);
          const berm = edge * edge * 0.12;
          pos.setZ(v, bumps + grit + berm);
        }
        roadGeo.computeVertexNormals();

        const road = new THREE.Mesh(roadGeo, roadMat);
        road.material = roadMat.clone();
        road.material.color.offsetHSL((Math.random() - 0.5) * 0.02, (Math.random() - 0.5) * 0.05, (Math.random() - 0.5) * 0.04);
        road.rotation.x = -Math.PI / 2;
        road.receiveShadow = true;
        road.position.y = 0;
        seg.add(road);

        const stripe = new THREE.Mesh(new THREE.PlaneGeometry(0.25, world.segmentLength), stripeMat);
        stripe.rotation.x = -Math.PI / 2;
        stripe.position.y = 0.01;
        seg.add(stripe);

        seg.position.z = -i * world.segmentLength;
        scene.add(seg);
        world.groundSegments.push(seg);
      }

      // No visible hard border rims; boundaries are handled by physics.
    }

    function startGame() {
      state.running = true;
      state.score = 0;
      state.distance = 0;
      state.time = 0;
      state.nextSpawnIn = 0;
      settings.forwardSpeed = 1;

      world.obstacles.forEach(o => scene.remove(o.mesh));
      world.obstacles = [];

      world.flames.forEach(p => scene.remove(p.mesh));
      world.flames = [];

      player.x = 0;
      player.vx = 0;
      player.y = 0;
      player.vy = 0;
      player.grounded = true;
      player.jumpHeld = false;
      player.wasGrounded = true;
      player.mesh.position.set(0, 0, 0);

      // First-person: keep the world view clean, but show handlebars.
      player.visible = !settings.firstPerson;
      player.mesh.visible = player.visible;
      if (player.fpRig) player.fpRig.visible = true;

      document.getElementById('overlay').style.display = 'none';
      document.getElementById('hud').style.display = 'block';
      document.getElementById('tip').style.display = 'block';

      clock.getDelta();
    }

    function crash() {
      if (!state.running) return;
      state.running = false;
      if (state.score > state.best) {
        state.best = state.score;
        localStorage.setItem('dirtbike_best', String(state.best));
      }
      document.getElementById('best').textContent = state.best;

      triggerExplosion(player.mesh.position.clone());
      state.restartIn = 1.15;
      state.shakeTime = 0.35;
      state.shakeStrength = 0.45;

      // Show bike briefly during the explosion.
      player.mesh.visible = true;
      if (player.fpRig) player.fpRig.visible = false;
    }

    function triggerExplosion(position) {
      for (const p of world.explosionParticles) {
        scene.remove(p.mesh);
      }
      world.explosionParticles = [];

      if (world.explosionLight) {
        scene.remove(world.explosionLight);
        world.explosionLight = null;
      }

      const light = new THREE.PointLight(0xffb14a, 7.0, 35, 2);
      light.position.copy(position);
      light.position.y = 2.0;
      scene.add(light);
      world.explosionLight = light;

      const fireCount = 55;
      const smokeCount = 28;

      for (let i = 0; i < fireCount; i++) {
        const mesh = new THREE.Mesh(
          new THREE.SphereGeometry(0.12 + Math.random() * 0.22, 8, 8),
          new THREE.MeshBasicMaterial({
            color: new THREE.Color().setHSL(0.02 + Math.random() * 0.06, 1.0, 0.55),
            transparent: true,
            opacity: 0.95,
            depthWrite: false,
          })
        );
        mesh.position.copy(position);
        mesh.position.y = 1.0;
        const v = new THREE.Vector3((Math.random() - 0.5) * 10, 4 + Math.random() * 6, (Math.random() - 0.5) * 10);
        world.explosionParticles.push({ mesh, vel: v, life: 0.55 + Math.random() * 0.25, age: 0, drag: 1.35 });
        scene.add(mesh);
      }

      for (let i = 0; i < smokeCount; i++) {
        const mesh = new THREE.Mesh(
          new THREE.SphereGeometry(0.28 + Math.random() * 0.35, 7, 7),
          new THREE.MeshBasicMaterial({
            color: 0x2a2a2a,
            transparent: true,
            opacity: 0.55,
            depthWrite: false,
          })
        );
        mesh.position.copy(position);
        mesh.position.y = 1.1;
        const v = new THREE.Vector3((Math.random() - 0.5) * 4, 2.0 + Math.random() * 3.5, (Math.random() - 0.5) * 4);
        world.explosionParticles.push({ mesh, vel: v, life: 1.2 + Math.random() * 0.6, age: 0, drag: 0.6 });
        scene.add(mesh);
      }
    }

    function spawnObstacle() {
      const x = (Math.random() * 2 - 1) * (settings.roadHalfWidth - 1.6);
      const z = -(settings.obstacleSpawnMinZ + Math.random() * (settings.obstacleSpawnMaxZ - settings.obstacleSpawnMinZ));

      const type = Math.random();
      let mesh;

      if (type < 0.6) {
        const mat = new THREE.MeshStandardMaterial({ color: 0x3b2f2f, roughness: 0.95, metalness: 0.0 });
        mesh = new THREE.Mesh(new THREE.DodecahedronGeometry(1.3, 0), mat);
        mesh.position.y = 1.05;
      } else {
        const mat = new THREE.MeshStandardMaterial({ color: 0x2b3d2a, roughness: 0.95, metalness: 0.0 });
        mesh = new THREE.Mesh(new THREE.ConeGeometry(1.0, 2.6, 10), mat);
        mesh.position.y = 0.8;
      }

      mesh.castShadow = true;
      mesh.receiveShadow = true;
      mesh.position.x = x;
      mesh.position.z = z;
      scene.add(mesh);

      world.obstacles.push({ mesh, radius: settings.obstacleRadius });
    }

    function spawnDustBurst(position, amount, strength) {
      for (let i = 0; i < amount; i++) {
        const mesh = new THREE.Mesh(
          new THREE.SphereGeometry(0.06 + Math.random() * 0.08, 6, 6),
          new THREE.MeshBasicMaterial({ color: 0xd2b48c, transparent: true, opacity: 0.55, depthWrite: false })
        );
        mesh.position.copy(position);
        mesh.position.y += 0.15;
        const vel = new THREE.Vector3(
          (Math.random() - 0.5) * 2.8,
          0.8 + Math.random() * 1.4,
          (0.8 + Math.random() * 1.4) * strength
        );
        world.dustParticles.push({ mesh, vel, life: 0.55 + Math.random() * 0.35, age: 0 });
        scene.add(mesh);
      }
      while (world.dustParticles.length > 220) {
        const old = world.dustParticles.shift();
        scene.remove(old.mesh);
      }
    }

    function updateDust(dt) {
      for (let i = world.dustParticles.length - 1; i >= 0; i--) {
        const p = world.dustParticles[i];
        p.age += dt;
        p.mesh.position.addScaledVector(p.vel, dt);
        p.vel.y -= 2.4 * dt;
        p.vel.multiplyScalar(1 - clamp(1.4 * dt, 0, 0.25));
        const t = p.age / p.life;
        p.mesh.material.opacity = (1 - t) * 0.55;
        p.mesh.scale.setScalar(1 + t * 2.2);
        if (p.age >= p.life || p.mesh.material.opacity <= 0.02) {
          scene.remove(p.mesh);
          world.dustParticles.splice(i, 1);
        }
      }
    }

    function spawnFlame(dt) {
      const speedT = clamp((settings.forwardSpeed - 35) / 65, 0, 1);
      const intensity = 0.25 + speedT * 0.75;

      const p = {
        mesh: new THREE.Mesh(
          new THREE.SphereGeometry(0.14 + Math.random() * 0.12, 6, 6),
          new THREE.MeshBasicMaterial({
            color: new THREE.Color().setHSL(0.09 + Math.random() * 0.03, 0.55, 0.52),
            transparent: true,
            opacity: 0.65 * intensity,
            depthWrite: false,
          })
        ),
        life: 0.55 + Math.random() * 0.25,
        age: 0,
        vel: new THREE.Vector3(
          (Math.random() - 0.5) * 1.4,
          Math.random() * 0.65,
          (1.1 + Math.random() * 1.1) * intensity
        ),
      };

      const behind = new THREE.Vector3(0, 1.0, 1.8);
      behind.applyAxisAngle(new THREE.Vector3(0,1,0), 0);
      p.mesh.position.copy(player.mesh.position).add(behind);
      scene.add(p.mesh);
      world.flames.push(p);

      while (world.flames.length > 140) {
        const old = world.flames.shift();
        scene.remove(old.mesh);
      }

      player.mesh.flame.material.opacity = 0.15 + 0.55 * intensity;
      player.mesh.flame.scale.setScalar(0.85 + 0.9 * intensity);
    }

    function updateFlames(dt) {
      for (let i = world.flames.length - 1; i >= 0; i--) {
        const p = world.flames[i];
        p.age += dt;
        p.mesh.position.addScaledVector(p.vel, dt);
        p.vel.y -= 2.2 * dt;
        p.vel.z += 1.4 * dt;
        const t = p.age / p.life;
        p.mesh.material.opacity = (1 - t) * 0.6;
        p.mesh.scale.setScalar(1 + t * 1.8);
        if (p.age >= p.life || p.mesh.material.opacity <= 0.02) {
          scene.remove(p.mesh);
          world.flames.splice(i, 1);
        }
      }
      if (!state.running) {
        player.mesh.flame.material.opacity *= 0.85;
      }
    }

    function updateExplosion(dt) {
      for (let i = world.explosionParticles.length - 1; i >= 0; i--) {
        const p = world.explosionParticles[i];
        p.age += dt;
        p.mesh.position.addScaledVector(p.vel, dt);
        p.vel.multiplyScalar(1 - clamp(p.drag * dt, 0, 0.85));
        p.vel.y -= 9.8 * dt * (p.drag > 1 ? 0.55 : 0.25);
        const t = p.age / p.life;
        p.mesh.material.opacity = (1 - t) * (p.drag > 1 ? 0.95 : 0.55);
        p.mesh.scale.setScalar(1 + t * (p.drag > 1 ? 1.6 : 2.4));
        if (p.age >= p.life || p.mesh.material.opacity <= 0.02) {
          scene.remove(p.mesh);
          world.explosionParticles.splice(i, 1);
        }
      }

      if (world.explosionLight) {
        world.explosionLight.intensity *= Math.pow(0.05, dt);
        if (world.explosionLight.intensity < 0.05) {
          scene.remove(world.explosionLight);
          world.explosionLight = null;
        }
      }
    }

    function update(dt) {
      if (!state.running) {
        if (state.restartIn > 0) {
          state.restartIn -= dt;
          if (state.restartIn <= 0) {
            startGame();
          }
        }
        return;
      }

      state.time += dt;
      state.distance += settings.forwardSpeed * dt;
      state.score = Math.floor(state.distance);

      settings.forwardSpeed = settings.forwardSpeed + (settings.forwardAccel + settings.forwardSpeed * 0.015) * dt;

      const left = keys['a'] || keys['arrowleft'];
      const right = keys['d'] || keys['arrowright'];
      const ax = (right ? 1 : 0) - (left ? 1 : 0);

      const jumpKey = keys[' '] || keys['arrowup'];
      if (jumpKey && !player.jumpHeld && player.grounded) {
        player.vy = settings.jumpVelocity;
        player.grounded = false;
      }
      player.jumpHeld = !!jumpKey;

      if (!player.grounded) {
        player.vy -= settings.gravity * dt;
        player.y += player.vy * dt;
        if (player.y <= 0) {
          player.y = 0;
          player.vy = 0;
          player.grounded = true;
        }
      }

      if (!player.wasGrounded && player.grounded) {
        const p = player.mesh.position.clone();
        spawnDustBurst(p, 22, clamp(settings.forwardSpeed / 30, 0.8, 3.2));
      }
      player.wasGrounded = player.grounded;

      player.vx += ax * settings.lateralAccel * dt;
      player.vx = clamp(player.vx, -settings.lateralMaxSpeed, settings.lateralMaxSpeed);

      if (ax === 0) {
        const sign = Math.sign(player.vx);
        const decel = settings.lateralFriction * dt;
        const next = Math.abs(player.vx) - decel;
        player.vx = next <= 0 ? 0 : sign * next;
      }

      player.x += player.vx * dt;
      const edge = settings.roadHalfWidth - player.radius;
      const over = Math.abs(player.x) - edge;
      if (over > 0) {
        player.vx -= Math.sign(player.x) * over * 85 * dt;
        player.x = clamp(player.x, -edge - 3.5, edge + 3.5);
      }

      player.mesh.position.x = player.x;
      player.mesh.position.y = player.y;
      player.mesh.rotation.y = (-player.vx / settings.lateralMaxSpeed) * 0.25;
      player.mesh.rotation.z = (-player.vx / settings.lateralMaxSpeed) * 0.18;

      const moveZ = settings.forwardSpeed * dt;
      for (const seg of world.groundSegments) {
        seg.position.z += moveZ;
        if (seg.position.z > world.segmentLength) {
          seg.position.z -= world.segmentCount * world.segmentLength;
        }
      }

      state.nextSpawnIn -= dt;
      if (state.nextSpawnIn <= 0) {
        const scaled = Math.max(0.12, settings.obstacleSpawnInterval * (18 / Math.max(1, settings.forwardSpeed)));
        state.nextSpawnIn = scaled;
        spawnObstacle();
      }

      for (let i = world.obstacles.length - 1; i >= 0; i--) {
        const o = world.obstacles[i];
        o.mesh.position.z += moveZ;
        if (o.mesh.position.z > 20) {
          scene.remove(o.mesh);
          world.obstacles.splice(i, 1);
          continue;
        }

        if (player.y < settings.jumpClearance) {
          const dx = o.mesh.position.x - player.mesh.position.x;
          const dz = o.mesh.position.z - player.mesh.position.z;
          const dist = Math.sqrt(dx * dx + dz * dz);
          if (dist < (o.radius + player.radius)) {
            crash();
            break;
          }
        }
      }

      if (Math.abs(player.vx) > 6 || settings.forwardSpeed > 65) {
        if (Math.random() < 0.35) spawnFlame(dt);
      }

      document.getElementById('score').textContent = state.score;
      document.getElementById('best').textContent = state.best;
      document.getElementById('speed').textContent = Math.round(settings.forwardSpeed);

      if (settings.firstPerson) {
        camera.position.x = player.mesh.position.x * 0.55;
        camera.position.y = settings.fpHeight + player.y;
        camera.position.z = settings.fpForward;
        camera.lookAt(player.mesh.position.x * 0.55, settings.fpHeight + player.y * 0.7, settings.fpLookAhead);
      } else {
        camera.position.x = player.mesh.position.x * 0.65;
        camera.position.y = settings.cameraHeight;
        camera.position.z = settings.cameraBack;
        camera.lookAt(player.mesh.position.x * 0.4, 1.0, settings.cameraLookAhead);
      }
    }

    function animate() {
      requestAnimationFrame(animate);
      const dt = Math.min(0.05, clock.getDelta());
      update(dt);
      updateFlames(dt);
      updateExplosion(dt);
      updateDust(dt);

      const baseCamX = camera.position.x;
      const baseCamY = camera.position.y;

      if (state.shakeTime > 0) {
        state.shakeTime -= dt;
      }
      const shakeT = clamp(state.shakeTime / 0.35, 0, 1);
      if (shakeT > 0) {
        const s = state.shakeStrength * shakeT;
        camera.position.x = baseCamX + (Math.random() - 0.5) * s;
        camera.position.y = baseCamY + (Math.random() - 0.5) * s;
      }
      renderer.render(scene, camera);
    }

    document.getElementById('start').addEventListener('click', () => {
      startGame();
    });

    init();
  </script>
</body>
</html>
