<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Racing Game 2 - Arcade Physics</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            overflow: hidden;
        }
        
        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        #canvas {
            border: 3px solid rgba(255, 255, 255, 0.3);
            box-shadow: 0 25px 50px rgba(0, 0, 0, 0.3);
            background: linear-gradient(to bottom, #87CEEB 0%, #98D8E8 100%);
        }
        
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 15px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            min-width: 200px;
        }
        
        .stat {
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .stat-label {
            font-weight: bold;
            color: #64b5f6;
        }
        
        .stat-value {
            color: #fff;
            font-family: 'Courier New', monospace;
            font-weight: bold;
        }
        
        #controls {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 15px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        #controls h4 {
            margin-bottom: 15px;
            color: #64b5f6;
            text-align: center;
        }
        
        #controls ul {
            list-style: none;
        }
        
        #controls li {
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        
        .key {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 4px 8px;
            border-radius: 5px;
            font-weight: bold;
            font-size: 12px;
            min-width: 30px;
            text-align: center;
            margin-right: 10px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }
        
        #physics {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 15px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            font-size: 12px;
        }
        
        #physics h4 {
            margin-bottom: 10px;
            color: #64b5f6;
        }
        
        .physics-stat {
            margin-bottom: 5px;
            display: flex;
            justify-content: space-between;
        }
        
        .physics-label {
            color: #aaa;
        }
        
        .physics-value {
            color: #4fc3f7;
            font-weight: bold;
        }
        
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            font-size: 24px;
            color: white;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }
        
        .pulse {
            animation: pulse 1.5s infinite;
        }
        
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="canvas" width="1200" height="800"></canvas>
        
        <div id="ui">
            <h3>üèéÔ∏è Speed Stats</h3>
            <div class="stat">
                <span class="stat-label">Speed:</span>
                <span class="stat-value" id="speed">0 km/h</span>
            </div>
            <div class="stat">
                <span class="stat-label">Position:</span>
                <span class="stat-value" id="position">0, 0</span>
            </div>
            <div class="stat">
                <span class="stat-label">Height:</span>
                <span class="stat-value" id="height">0.0m</span>
            </div>
            <div class="stat">
                <span class="stat-label">Drift:</span>
                <span class="stat-value" id="drift" style="color: #ff6666;">OFF</span>
            </div>
        </div>
        
        <div id="controls">
            <h4>‚å®Ô∏è Controls</h4>
            <ul>
                <li><span class="key">W</span> / <span class="key">‚Üë</span> - Accelerate</li>
                <li><span class="key">S</span> / <span class="key">‚Üì</span> - Brake</li>
                <li><span class="key">A</span> / <span class="key">‚Üê</span> - Turn Left</li>
                <li><span class="key">D</span> / <span class="key">‚Üí</span> - Turn Right</li>
                <li><span class="key">Space</span> - Jump</li>
                <li><span class="key">E</span> - Drift Mode</li>
            </ul>
        </div>
        
        <div id="physics">
            <h4>üî¨ Physics Mode</h4>
            <div class="physics-stat">
                <span class="physics-label">Friction:</span>
                <span class="physics-value">Low</span>
            </div>
            <div class="physics-stat">
                <span class="physics-label">Gravity:</span>
                <span class="physics-value">50%</span>
            </div>
            <div class="physics-stat">
                <span class="physics-label">Max Speed:</span>
                <span class="physics-value">250 km/h</span>
            </div>
            <div class="physics-stat">
                <span class="physics-label">Drift:</span>
                <span class="physics-value">Enhanced</span>
            </div>
        </div>
        
        <div id="loading" class="pulse">üèÅ Loading Racing Game 2...</div>
    </div>
    
    <script>
        // This will be replaced with the compiled WebAssembly module
        // For now, this is a placeholder showing how the integration works
        
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        // Temporary JavaScript version for testing before WASM compilation
        let car = {
            x: 600,
            y: 400,
            z: 0,
            vx: 0,
            vy: 0,
            vz: 0,
            rotation: 0,
            speed: 0,
            width: 50,
            height: 100,
            isGrounded: true,
            pitch: 0,
            roll: 0
        };
        
        const keys = {};
        // Physics constants - reduced friction and gravity
        const SPEED_SCALE = 15; // 1 km/h = 15 units
        const MAX_SPEED_KMH = 250; // Maximum speed in km/h
        const MAX_SPEED = MAX_SPEED_KMH * SPEED_SCALE; // 3750 units
        const ACCELERATION = 8.0; // Faster acceleration
        const TURN_SPEED = 0.08;
        const FRICTION = 0.98; // Less friction (higher value = less slowdown)
        const WORLD_SIZE = 800;
        const DRIFT_THRESHOLD = 80 * SPEED_SCALE; // 80 km/h = 1200 units
        const GRAVITY = 9.8 * 0.5; // Reduced gravity (half real gravity)
        const JUMP_POWER = 15;
        
        // Camera
        let cameraX = 0, cameraY = 0, cameraZ = 100;
        
        // Particle system for dust
        const particles = [];
        const MAX_PARTICLES = 50;
        
        class Particle {
            constructor(x, y, z) {
                this.x = x + (Math.random() - 0.5) * 20;
                this.y = y + (Math.random() - 0.5) * 20;
                this.z = z;
                this.vx = (Math.random() - 0.5) * 5;
                this.vy = (Math.random() - 0.5) * 5;
                this.vz = Math.random() * 3;
                this.life = 1.0;
                this.size = 3 + Math.random() * 5;
                this.color = `rgba(${200 + Math.random() * 55}, ${180 + Math.random() * 40}, ${120 + Math.random() * 30}, `;
            }
            
            update(dt) {
                this.x += this.vx;
                this.y += this.vy;
                this.z += this.vz;
                this.vz -= GRAVITY * dt * 0.1;
                this.life -= dt * 2;
                this.size += dt * 10;
            }
            
            draw(ctx, offsetX, offsetY) {
                const screenX = this.x - offsetX;
                const screenY = this.y - offsetY;
                const size = this.size * (1 - this.z * 0.01);
                
                ctx.fillStyle = this.color + (this.life * 0.6) + ')';
                ctx.beginPath();
                ctx.arc(screenX, screenY, size, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        // Input handling
        window.addEventListener('keydown', (e) => {
            const key = e.key.toLowerCase();
            keys[key] = true;
            // Arrow keys
            if (e.key === 'ArrowUp') keys['w'] = true;
            if (e.key === 'ArrowDown') keys['s'] = true;
            if (e.key === 'ArrowLeft') keys['a'] = true;
            if (e.key === 'ArrowRight') keys['d'] = true;
            // Spacebar
            if (e.key === ' ') keys[' '] = true;
            
            if (e.key.startsWith('Arrow') || e.key === ' ') {
                e.preventDefault();
            }
        });
        
        window.addEventListener('keyup', (e) => {
            const key = e.key.toLowerCase();
            keys[key] = false;
            // Arrow keys
            if (e.key === 'ArrowUp') keys['w'] = false;
            if (e.key === 'ArrowDown') keys['s'] = false;
            if (e.key === 'ArrowLeft') keys['a'] = false;
            if (e.key === 'ArrowRight') keys['d'] = false;
            // Spacebar
            if (e.key === ' ') keys[' '] = false;
        });
        
        function updateCar() {
            // Acceleration
            if (keys['w']) {
                car.speed += ACCELERATION;
            } else if (keys['s']) {
                car.speed -= ACCELERATION * 1.5; // Stronger braking
            } else {
                // Natural deceleration (less friction)
                car.speed *= FRICTION;
            }
            
            // Clamp speed
            car.speed = Math.max(-MAX_SPEED * 0.3, Math.min(MAX_SPEED, car.speed));
            
            // Jump mechanics
            if (keys[' '] && car.isGrounded) {
                car.vz = JUMP_POWER;
                car.isGrounded = false;
                
                // Create jump particles
                for (let i = 0; i < 10; i++) {
                    particles.push(new Particle(car.x, car.y, 0));
                }
            }
            
            // Apply gravity (reduced)
            if (!car.isGrounded) {
                car.vz -= GRAVITY * 0.016; // 60fps frame time
                car.z += car.vz * 0.016;
                
                // Ground collision
                if (car.z <= 0) {
                    car.z = 0;
                    car.vz = 0;
                    car.isGrounded = true;
                    
                    // Create landing particles
                    for (let i = 0; i < 5; i++) {
                        particles.push(new Particle(car.x, car.y, 0));
                    }
                }
            }
            
            // Steering with drift
            if (Math.abs(car.speed) > 0.1) {
                const turnFactor = car.speed / MAX_SPEED;
                const isDrifting = keys['e'] && Math.abs(car.speed) > DRIFT_THRESHOLD;
                const driftMultiplier = isDrifting ? 2.0 : 1.0;
                
                let steerInput = 0;
                if (keys['a']) {
                    steerInput = -TURN_SPEED * turnFactor * driftMultiplier;
                    car.rotation += steerInput;
                }
                if (keys['d']) {
                    steerInput = TURN_SPEED * turnFactor * driftMultiplier;
                    car.rotation += steerInput;
                }
                
                // Drift physics
                if (isDrifting && Math.abs(steerInput) > 0.001) {
                    const driftAmount = Math.min((Math.abs(car.speed) - DRIFT_THRESHOLD) / DRIFT_THRESHOLD, 1.0);
                    const slideX = Math.cos(car.rotation) * steerInput * driftAmount * 8;
                    const slideY = -Math.sin(car.rotation) * steerInput * driftAmount * 8;
                    
                    car.vx += slideX;
                    car.vy += slideY;
                    
                    // Create drift particles
                    if (Math.random() < 0.3) {
                        particles.push(new Particle(car.x, car.y, 0));
                    }
                }
                
                // Apply friction to lateral velocity (less friction)
                car.vx *= FRICTION;
                car.vy *= FRICTION;
            }
            
            // Update position
            car.x += Math.sin(car.rotation) * car.speed * 0.016 + car.vx * 0.016;
            car.y += Math.cos(car.rotation) * car.speed * 0.016 + car.vy * 0.016;
            
            // World boundaries with bounce
            if (Math.abs(car.x) > WORLD_SIZE) {
                car.x = (car.x > 0) ? WORLD_SIZE : -WORLD_SIZE;
                car.speed *= -0.5;
                car.vx *= -0.5;
            }
            if (Math.abs(car.y) > WORLD_SIZE) {
                car.y = (car.y > 0) ? WORLD_SIZE : -WORLD_SIZE;
                car.speed *= -0.5;
                car.vy *= -0.5;
            }
            
            // Update car tilt
            car.pitch = car.vx * 0.01;
            car.roll = -car.vy * 0.01;
            
            // Update camera to follow car
            cameraX = car.x - Math.sin(car.rotation) * 150;
            cameraY = car.y - Math.cos(car.rotation) * 150;
            cameraZ = car.z + 100;
            
            // Update UI
            const speedKmh = Math.abs(car.speed) / SPEED_SCALE;
            document.getElementById('speed').textContent = speedKmh.toFixed(1) + ' km/h';
            document.getElementById('position').textContent = `${car.x.toFixed(0)}, ${car.y.toFixed(0)}`;
            document.getElementById('height').textContent = car.z.toFixed(1) + 'm';
            
            // Show drift status
            const isDriftActive = keys['e'] && Math.abs(car.speed) > DRIFT_THRESHOLD;
            const driftElement = document.getElementById('drift');
            if (isDriftActive) {
                driftElement.textContent = 'ON';
                driftElement.style.color = '#00ff00';
            } else {
                driftElement.textContent = 'OFF';
                driftElement.style.color = '#ff6666';
            }
        }
        
        function updateParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                const particle = particles[i];
                particle.update(0.016);
                
                if (particle.life <= 0) {
                    particles.splice(i, 1);
                }
            }
        }
        
        function drawGround() {
            const tileSize = 50;
            const startX = Math.floor(cameraX / tileSize) * tileSize;
            const startY = Math.floor(cameraY / tileSize) * tileSize;
            const endX = startX + canvas.width + tileSize;
            const endY = startY + canvas.height + tileSize;
            
            for (let x = startX; x < endX; x += tileSize) {
                for (let y = startY; y < endY; y += tileSize) {
                    const screenX = x - cameraX;
                    const screenY = y - cameraY;
                    
                    // Checkerboard pattern
                    if ((Math.floor(x / tileSize) + Math.floor(y / tileSize)) % 2 === 0) {
                        ctx.fillStyle = '#2ecc71';
                    } else {
                        ctx.fillStyle = '#27ae60';
                    }
                    
                    ctx.fillRect(screenX, screenY, tileSize, tileSize);
                }
            }
        }
        
        function drawCar() {
            const screenX = car.x - cameraX;
            const screenY = car.y - cameraY;
            
            ctx.save();
            ctx.translate(screenX, screenY);
            ctx.rotate(car.rotation);
            
            // Car shadow
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.fillRect(-car.width/2 + 5, -car.height/2 + 5, car.width, car.height * 0.6);
            
            // Car body - sporty red
            ctx.fillStyle = '#cc1a1a';
            ctx.fillRect(-car.width/2, -car.height/2, car.width, car.height * 0.6);
            
            // Car roof
            ctx.fillStyle = '#990000';
            ctx.fillRect(-car.width/2 + 5, -car.height/2 + 10, car.width - 10, car.height * 0.3);
            
            // Windows
            ctx.fillStyle = '#1a1a3a';
            ctx.fillRect(-car.width/2 + 8, -car.height/2 + 15, car.width - 16, car.height * 0.15);
            
            // Wheels
            ctx.fillStyle = '#1a1a1a';
            // Front wheels
            ctx.fillRect(-car.width/2 - 3, -car.height/2 + 10, 6, 15);
            ctx.fillRect(car.width/2 - 3, -car.height/2 + 10, 6, 15);
            // Rear wheels
            ctx.fillRect(-car.width/2 - 3, car.height/2 - 25, 6, 15);
            ctx.fillRect(car.width/2 - 3, car.height/2 - 25, 6, 15);
            
            ctx.restore();
        }
        
        function gameLoop() {
            // Clear canvas
            ctx.fillStyle = '#87CEEB';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Update
            updateCar();
            updateParticles();
            
            // Draw
            drawGround();
            
            // Draw particles
            particles.forEach(particle => {
                particle.draw(ctx, cameraX, cameraY);
            });
            
            drawCar();
            
            requestAnimationFrame(gameLoop);
        }
        
        // Hide loading and start game
        setTimeout(() => {
            document.getElementById('loading').style.display = 'none';
            gameLoop();
        }, 1000);
    </script>
</body>
</html>
