<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Medieval Knight - First Person</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body { width: 100%; height: 100%; background: #000; overflow: hidden; font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; }

    #gameRoot { position: fixed; inset: 0; }
    canvas { display: block; width: 100%; height: 100%; }

    #menu {
      position: fixed;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      background: radial-gradient(circle at 30% 20%, rgba(255,255,255,0.08), rgba(0,0,0,0) 50%),
                  linear-gradient(135deg, #0b0b0b, #151515);
      color: #f5f5f5;
      z-index: 10;
      padding: 24px;
    }

    .panel {
      width: min(980px, 100%);
      background: rgba(0,0,0,0.72);
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 16px;
      box-shadow: 0 18px 60px rgba(0,0,0,0.6);
      overflow: hidden;
    }

    .panelHeader {
      padding: 18px 22px;
      background: linear-gradient(135deg, rgba(255,215,0,0.12), rgba(255,255,255,0));
      border-bottom: 1px solid rgba(255,255,255,0.12);
      display: flex;
      justify-content: space-between;
      gap: 12px;
      align-items: baseline;
    }

    .title { font-size: 22px; font-weight: 800; letter-spacing: 0.5px; }
    .subtitle { font-size: 13px; color: rgba(255,255,255,0.75); }

    .panelBody {
      padding: 18px 22px 22px 22px;
      display: grid;
      grid-template-columns: 1.1fr 0.9fr;
      gap: 18px;
    }

    @media (max-width: 860px) {
      .panelBody { grid-template-columns: 1fr; }
    }

    .card {
      background: rgba(255,255,255,0.06);
      border: 1px solid rgba(255,255,255,0.1);
      border-radius: 14px;
      padding: 16px;
    }

    .row { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }

    select {
      background: rgba(0,0,0,0.6);
      color: #f5f5f5;
      border: 1px solid rgba(255,255,255,0.16);
      border-radius: 10px;
      padding: 10px 12px;
      font-weight: 600;
      outline: none;
      min-width: 220px;
    }

    button {
      appearance: none;
      border: none;
      border-radius: 12px;
      padding: 12px 16px;
      font-weight: 800;
      cursor: pointer;
      transition: transform 0.12s ease, filter 0.2s ease;
    }

    button.primary {
      background: linear-gradient(135deg, #facc15, #f59e0b);
      color: #0a0a0a;
      box-shadow: 0 14px 30px rgba(245, 158, 11, 0.18);
    }

    button.secondary {
      background: rgba(255,255,255,0.08);
      color: rgba(255,255,255,0.92);
      border: 1px solid rgba(255,255,255,0.14);
    }

    button:hover { transform: translateY(-1px); filter: brightness(1.03); }
    button:active { transform: translateY(0px); filter: brightness(0.98); }

    .controlsList {
      display: grid;
      grid-template-columns: 1fr;
      gap: 10px;
      font-size: 14px;
      color: rgba(255,255,255,0.92);
    }

    .key {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      min-width: 30px;
      padding: 4px 8px;
      border-radius: 8px;
      background: rgba(250, 204, 21, 0.12);
      border: 1px solid rgba(250, 204, 21, 0.25);
      font-weight: 900;
      margin-right: 10px;
      color: #facc15;
    }

    #hud {
      position: fixed;
      inset: 0;
      pointer-events: none;
      display: none;
      z-index: 5;
    }

    #crosshair {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 18px;
      height: 18px;
      opacity: 0.95;
    }

    #crosshair::before,
    #crosshair::after {
      content: '';
      position: absolute;
      background: rgba(250, 204, 21, 0.9);
      box-shadow: 0 0 8px rgba(250, 204, 21, 0.35);
    }

    #crosshair::before { width: 2px; height: 18px; left: 50%; top: 0; transform: translateX(-50%); }
    #crosshair::after { height: 2px; width: 18px; top: 50%; left: 0; transform: translateY(-50%); }

    #prompt {
      position: absolute;
      left: 50%;
      top: calc(50% + 34px);
      transform: translateX(-50%);
      padding: 8px 12px;
      border-radius: 12px;
      background: rgba(0,0,0,0.6);
      border: 1px solid rgba(255,255,255,0.12);
      color: rgba(255,255,255,0.92);
      font-weight: 700;
      display: none;
      text-align: center;
      max-width: min(520px, 92vw);
    }

    #status {
      position: absolute;
      left: 14px;
      top: 14px;
      padding: 10px 12px;
      border-radius: 12px;
      background: rgba(0,0,0,0.55);
      border: 1px solid rgba(255,255,255,0.12);
      color: rgba(255,255,255,0.92);
      font-weight: 700;
      font-size: 13px;
      display: none;
      max-width: min(520px, 94vw);
    }

    #cornerControls {
      position: absolute;
      right: 14px;
      top: 14px;
      padding: 10px 12px;
      border-radius: 12px;
      background: rgba(0,0,0,0.55);
      border: 1px solid rgba(255,255,255,0.12);
      color: rgba(255,255,255,0.9);
      font-weight: 700;
      font-size: 12px;
      line-height: 1.4;
      display: none;
    }
  </style>
</head>
<body>
  <div id="gameRoot"></div>

  <div id="menu">
    <div class="panel">
      <div class="panelHeader">
        <div>
          <div class="title">Medieval Knight</div>
          <div class="subtitle">First-person prototype: 3 maps + basic controls</div>
        </div>
        <a href="../../games.html" style="color: rgba(255,255,255,0.7); text-decoration: none; font-weight: 700;">Back to Games</a>
      </div>
      <div class="panelBody">
        <div class="card">
          <div style="font-weight: 900; margin-bottom: 10px;">Start</div>
          <div class="row" style="margin-bottom: 12px;">
            <label for="mapSelect" style="font-weight: 800; color: rgba(255,255,255,0.9);">Map:</label>
            <select id="mapSelect">
              <option value="village">Grayfield Village</option>
              <option value="bridge">Riverrun Ford (Bridge)</option>
              <option value="fortress">Blackgate Courtyard</option>
            </select>
            <button class="primary" id="startBtn">Play</button>
            <button class="secondary" id="customBtn">Custom Battle</button>
          </div>
          <div style="color: rgba(255,255,255,0.78); font-size: 14px; line-height: 1.55;">
            Click Play, then click the screen to lock the mouse.
            Press ESC to unlock.
          </div>
        </div>

        <div class="card" id="customBattleCard" style="display:none;">
          <div style="font-weight: 900; margin-bottom: 10px;">Custom Battle</div>
          <div class="row" style="margin-bottom: 12px;">
            <label for="customMapSelect" style="font-weight: 800; color: rgba(255,255,255,0.9);">Map:</label>
            <select id="customMapSelect">
              <option value="village">Grayfield Village</option>
              <option value="bridge">Riverrun Ford (Bridge)</option>
              <option value="fortress">Blackgate Courtyard</option>
            </select>
          </div>

          <div class="row" style="margin-bottom: 12px;">
            <label for="countFoot" style="font-weight: 800; color: rgba(255,255,255,0.9);">Footsoldier:</label>
            <input id="countFoot" type="number" min="0" max="200" value="12" style="background: rgba(0,0,0,0.6); color:#f5f5f5; border: 1px solid rgba(255,255,255,0.16); border-radius: 10px; padding: 10px 12px; font-weight: 700; width: 110px;" />
            <span style="color: rgba(255,255,255,0.7); font-weight: 700;">(max 200)</span>
          </div>
          <div class="row" style="margin-bottom: 12px;">
            <label for="countArcher" style="font-weight: 800; color: rgba(255,255,255,0.9);">Archer:</label>
            <input id="countArcher" type="number" min="0" max="100" value="6" style="background: rgba(0,0,0,0.6); color:#f5f5f5; border: 1px solid rgba(255,255,255,0.16); border-radius: 10px; padding: 10px 12px; font-weight: 700; width: 110px;" />
            <span style="color: rgba(255,255,255,0.7); font-weight: 700;">(max 100)</span>
          </div>
          <div class="row" style="margin-bottom: 12px;">
            <label for="countKnight" style="font-weight: 800; color: rgba(255,255,255,0.9);">Knight:</label>
            <input id="countKnight" type="number" min="0" max="40" value="3" style="background: rgba(0,0,0,0.6); color:#f5f5f5; border: 1px solid rgba(255,255,255,0.16); border-radius: 10px; padding: 10px 12px; font-weight: 700; width: 110px;" />
            <span style="color: rgba(255,255,255,0.7); font-weight: 700;">(max 40)</span>
          </div>

          <div class="row" style="margin-bottom: 12px;">
            <label for="winCondition" style="font-weight: 800; color: rgba(255,255,255,0.9);">Win:</label>
            <select id="winCondition">
              <option value="capture_all">Win all areas</option>
              <option value="kills_800">Kill enemy above 800</option>
              <option value="hold_5m">Don't lose any area in 5 minutes</option>
            </select>
          </div>

          <div class="row">
            <button class="primary" id="startCustomBtn">Start Custom Battle</button>
            <button class="secondary" id="backCustomBtn">Back</button>
          </div>

          <div style="margin-top: 12px; color: rgba(255,255,255,0.78); font-size: 13px; line-height: 1.5;">
            Health: You 100 | Archer 30 | Footsoldier 60 | Knight 100
          </div>
        </div>

        <div class="card">
          <div style="font-weight: 900; margin-bottom: 10px;">Controls</div>
          <div class="controlsList">
            <div><span class="key">WASD</span>Move</div>
            <div><span class="key">Mouse</span>Look</div>
            <div><span class="key">E</span>Use / Interact (pick up weapon, talk to villager, ride horse)</div>
            <div><span class="key">F</span>Kick</div>
            <div><span class="key">LMB</span>Attack</div>
            <div><span class="key">RMB</span>Shield raise / Block</div>
            <div><span class="key">ESC</span>Unlock mouse</div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <div id="hud">
    <div id="crosshair"></div>
    <div id="prompt"></div>
    <div id="status"></div>
    <div id="cornerControls">WASD Move<br>E Interact<br>F Kick<br>LMB Attack<br>RMB Block</div>
    <div id="hp" style="position:absolute; left:14px; bottom:14px; padding: 10px 12px; border-radius: 12px; background: rgba(0,0,0,0.55); border: 1px solid rgba(255,255,255,0.12); color: rgba(255,255,255,0.92); font-weight: 800; font-size: 13px; display:none;"></div>
    <div id="objective" style="position:absolute; right:14px; bottom:14px; padding: 10px 12px; border-radius: 12px; background: rgba(0,0,0,0.55); border: 1px solid rgba(255,255,255,0.12); color: rgba(255,255,255,0.92); font-weight: 800; font-size: 13px; display:none; max-width: min(520px, 92vw); text-align:right; white-space: pre-line;"></div>
    <div id="endScreen" style="position:fixed; inset:0; background: rgba(0,0,0,0.86); display:none; align-items:center; justify-content:center; z-index: 100;">
      <div style="background: rgba(0,0,0,0.75); border: 1px solid rgba(255,255,255,0.12); border-radius: 16px; padding: 22px; width: min(720px, 92vw); color: #f5f5f5; text-align:center;">
        <div id="endTitle" style="font-size: 28px; font-weight: 900; margin-bottom: 10px;"></div>
        <div id="endBody" style="color: rgba(255,255,255,0.85); font-weight: 700; margin-bottom: 18px; line-height: 1.6;"></div>
        <button class="primary" id="endToMenuBtn">Back to Menu</button>
      </div>
    </div>
  </div>

  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
    }
  }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

    const gameRoot = document.getElementById('gameRoot');
    const menu = document.getElementById('menu');
    const startBtn = document.getElementById('startBtn');
    const customBtn = document.getElementById('customBtn');
    const mapSelect = document.getElementById('mapSelect');

    const customBattleCard = document.getElementById('customBattleCard');
    const customMapSelect = document.getElementById('customMapSelect');
    const countFootEl = document.getElementById('countFoot');
    const countArcherEl = document.getElementById('countArcher');
    const countKnightEl = document.getElementById('countKnight');
    const winConditionEl = document.getElementById('winCondition');
    const startCustomBtn = document.getElementById('startCustomBtn');
    const backCustomBtn = document.getElementById('backCustomBtn');

    const hud = document.getElementById('hud');
    const promptEl = document.getElementById('prompt');
    const statusEl = document.getElementById('status');
    const cornerControlsEl = document.getElementById('cornerControls');

    const hpEl = document.getElementById('hp');
    const objectiveEl = document.getElementById('objective');
    const endScreenEl = document.getElementById('endScreen');
    const endTitleEl = document.getElementById('endTitle');
    const endBodyEl = document.getElementById('endBody');
    const endToMenuBtn = document.getElementById('endToMenuBtn');

    customBtn.addEventListener('click', () => {
      customMapSelect.value = mapSelect.value;
      customBattleCard.style.display = 'block';
    });

    backCustomBtn.addEventListener('click', () => {
      customBattleCard.style.display = 'none';
    });

    let renderer;
    let scene;
    let camera;
    let controls;

    let clock;
    let keys = Object.create(null);

    let colliders = [];
    let interactables = [];

    let enemies = [];
    let currentMapId = 'village';

    let projectiles = [];
    let capturePoints = [];

    let battleSpawnPoints = [];
    let battleSpawnWeights = { foot: 1, archer: 1, knight: 1 };
    let respawnEnabled = false;
    let respawnQueue = [];
    let aliveCap = 0;

    let gameMode = 'story';
    let winCondition = 'capture_all';
    let kills = 0;
    let holdTimerSeconds = 300;

    const playerState = {
      maxHp: 100,
      hp: 100
    };

    const playerExternalVelocity = new THREE.Vector3();

    let hasSword = false;
    let isBlocking = false;
    let isMounted = false;

    let lastAttackTime = 0;
    let lastKickTime = 0;

    let horse;
    let villager;
    let villagerTarget = null;

    const player = {
      height: 1.7,
      radius: 0.35,
      walkSpeed: 5.5,
      mountedSpeed: 10.5,
      y: 1.7
    };

    function updateHud() {
      hpEl.style.display = 'block';
      hpEl.textContent = `HP: ${Math.ceil(playerState.hp)}/${playerState.maxHp}`;

      if (gameMode === 'custom') {
        objectiveEl.style.display = 'block';
        let areaOwned = 0;
        for (const p of capturePoints) {
          if (p.owner === 'player') areaOwned++;
        }

        if (winCondition === 'capture_all') {
          objectiveEl.textContent = `Objective: Capture all areas (${areaOwned}/${capturePoints.length})`;
        } else if (winCondition === 'kills_800') {
          objectiveEl.textContent = `Objective: Kills ${kills}/800\nAlive: ${enemies.length}/${aliveCap}`;
        } else if (winCondition === 'hold_5m') {
          const mm = String(Math.floor(holdTimerSeconds / 60)).padStart(1, '0');
          const ss = String(Math.floor(holdTimerSeconds % 60)).padStart(2, '0');
          objectiveEl.textContent = `Objective: Don't lose any area for 5:00\nOwned ${areaOwned}/${capturePoints.length} | Timer ${mm}:${ss}`;
        }
      } else {
        objectiveEl.style.display = 'none';
      }
    }

    function showEndScreen(title, body) {
      endTitleEl.textContent = title;
      endBodyEl.textContent = body;
      endScreenEl.style.display = 'flex';
      controls.unlock();
    }

    endToMenuBtn.addEventListener('click', () => {
      endScreenEl.style.display = 'none';
      customBattleCard.style.display = 'none';
      menu.style.display = 'flex';
    });

    function showPrompt(text) {
      if (!text) {
        promptEl.style.display = 'none';
        promptEl.textContent = '';
        return;
      }
      promptEl.textContent = text;
      promptEl.style.display = 'block';
    }

    let statusTimeout = null;
    function showStatus(text, ms = 1400) {
      if (!text) {
        statusEl.style.display = 'none';
        statusEl.textContent = '';
        return;
      }
      statusEl.textContent = text;
      statusEl.style.display = 'block';
      if (statusTimeout) window.clearTimeout(statusTimeout);
      statusTimeout = window.setTimeout(() => {
        statusEl.style.display = 'none';
      }, ms);
    }

    function clearWorld() {
      if (!scene) return;
      while (scene.children.length > 0) {
        scene.remove(scene.children[0]);
      }
      colliders = [];
      interactables = [];
      horse = null;
      villager = null;
      villagerTarget = null;
      hasSword = false;
      isBlocking = false;
      isMounted = false;

      projectiles = [];
      capturePoints = [];
      kills = 0;
      holdTimerSeconds = 300;
      playerState.hp = playerState.maxHp;
      endScreenEl.style.display = 'none';

      battleSpawnPoints = [];
      battleSpawnWeights = { foot: 1, archer: 1, knight: 1 };
      respawnEnabled = false;
      respawnQueue = [];
      aliveCap = 0;
    }

    function addCollider(mesh) {
      const box = new THREE.Box3().setFromObject(mesh);
      colliders.push({ mesh, box });
    }

    function updateColliders() {
      for (const c of colliders) {
        c.box.setFromObject(c.mesh);
      }
    }

    function addInteractable(mesh, type, label) {
      interactables.push({ mesh, type, label });
    }

    function clamp(v, min, max) {
      return Math.max(min, Math.min(max, v));
    }

    function isCollidingCapsule(pos, radius, height) {
      const size = new THREE.Vector3(radius * 2, height, radius * 2);
      const center = new THREE.Vector3(pos.x, height / 2, pos.z);
      const box = new THREE.Box3().setFromCenterAndSize(center, size);
      for (const c of colliders) {
        if (c.box.intersectsBox(box)) return true;
      }
      return false;
    }

    function tryMoveWithCollision(pos, vel, dt, radius, height) {
      const next = pos.clone().addScaledVector(vel, dt);

      const prev = pos.clone();
      pos.copy(next);

      if (!isCollidingCapsule(pos, radius, height)) return;

      pos.x = prev.x;
      if (!isCollidingCapsule(pos, radius, height)) {
        vel.x *= -0.35;
        return;
      }

      pos.x = prev.x;
      pos.z = next.z;
      if (!isCollidingCapsule(pos, radius, height)) {
        vel.z *= -0.35;
        return;
      }

      pos.copy(prev);
      vel.multiplyScalar(-0.15);
    }

    function createGround(size, color = 0x3b5f2a) {
      const geo = new THREE.PlaneGeometry(size, size, 1, 1);
      const mat = new THREE.MeshStandardMaterial({ color, roughness: 0.95, metalness: 0.0 });
      const ground = new THREE.Mesh(geo, mat);
      ground.rotation.x = -Math.PI / 2;
      ground.receiveShadow = true;
      scene.add(ground);
      return ground;
    }

    function createWallBox(w, h, d, color, x, y, z) {
      const mesh = new THREE.Mesh(
        new THREE.BoxGeometry(w, h, d),
        new THREE.MeshStandardMaterial({ color, roughness: 0.9, metalness: 0.05 })
      );
      mesh.position.set(x, y, z);
      mesh.castShadow = true;
      mesh.receiveShadow = true;
      scene.add(mesh);
      addCollider(mesh);
      return mesh;
    }

    function createHouse(x, z) {
      const body = new THREE.Mesh(
        new THREE.BoxGeometry(6, 3.2, 6),
        new THREE.MeshStandardMaterial({ color: 0x8b6a4b, roughness: 0.9 })
      );
      body.position.set(x, 1.6, z);
      body.castShadow = true;
      body.receiveShadow = true;
      scene.add(body);
      addCollider(body);

      const roof = new THREE.Mesh(
        new THREE.ConeGeometry(4.9, 2.4, 4),
        new THREE.MeshStandardMaterial({ color: 0x3a2a1a, roughness: 0.95 })
      );
      roof.position.set(x, 4.1, z);
      roof.rotation.y = Math.PI / 4;
      roof.castShadow = true;
      roof.receiveShadow = true;
      scene.add(roof);
      addCollider(roof);

      return { body, roof };
    }

    function createTree(x, z) {
      const trunk = new THREE.Mesh(
        new THREE.CylinderGeometry(0.35, 0.45, 3.2, 10),
        new THREE.MeshStandardMaterial({ color: 0x5a3c24, roughness: 0.95 })
      );
      trunk.position.set(x, 1.6, z);
      trunk.castShadow = true;
      trunk.receiveShadow = true;
      scene.add(trunk);
      addCollider(trunk);

      const leaves = new THREE.Mesh(
        new THREE.SphereGeometry(1.8, 12, 12),
        new THREE.MeshStandardMaterial({ color: 0x2e6b2e, roughness: 0.9 })
      );
      leaves.position.set(x, 3.6, z);
      leaves.castShadow = true;
      leaves.receiveShadow = true;
      scene.add(leaves);
      addCollider(leaves);

      return { trunk, leaves };
    }

    function createBarrel(x, z) {
      const barrel = new THREE.Mesh(
        new THREE.CylinderGeometry(0.55, 0.6, 1.1, 12),
        new THREE.MeshStandardMaterial({ color: 0x6b4f2a, roughness: 0.92 })
      );
      barrel.position.set(x, 0.55, z);
      barrel.castShadow = true;
      barrel.receiveShadow = true;
      scene.add(barrel);
      addCollider(barrel);
      return barrel;
    }

    function createCrate(x, z, w = 1.1, h = 1.1, d = 1.1) {
      const crate = new THREE.Mesh(
        new THREE.BoxGeometry(w, h, d),
        new THREE.MeshStandardMaterial({ color: 0x7a5a34, roughness: 0.95 })
      );
      crate.position.set(x, h / 2, z);
      crate.castShadow = true;
      crate.receiveShadow = true;
      scene.add(crate);
      addCollider(crate);
      return crate;
    }

    function createFenceSegment(x, z, length, horizontal = true) {
      const h = 1.1;
      const t = 0.2;
      const seg = new THREE.Mesh(
        new THREE.BoxGeometry(horizontal ? length : t, h, horizontal ? t : length),
        new THREE.MeshStandardMaterial({ color: 0x5a3c24, roughness: 0.95 })
      );
      seg.position.set(x, h / 2, z);
      seg.castShadow = true;
      seg.receiveShadow = true;
      scene.add(seg);
      addCollider(seg);
      return seg;
    }

    function createEnemySoldier(x, z) {
      return createEnemy('foot', x, z);
    }

    function createEnemy(type, x, z) {
      const group = new THREE.Group();

      const isKnight = type === 'knight';
      const isArcher = type === 'archer';

      const bodyColor = isKnight ? 0x374151 : (isArcher ? 0x7c2d12 : 0x4b5563);

      const body = new THREE.Mesh(
        new THREE.CapsuleGeometry(isKnight ? 0.5 : 0.42, isKnight ? 1.0 : 0.9, 6, 10),
        new THREE.MeshStandardMaterial({ color: bodyColor, roughness: 0.85 })
      );
      body.position.y = 1.1;
      body.castShadow = true;
      body.receiveShadow = true;
      group.add(body);

      const head = new THREE.Mesh(
        new THREE.SphereGeometry(0.24, 12, 12),
        new THREE.MeshStandardMaterial({ color: 0xffd1a8, roughness: 0.9 })
      );
      head.position.y = 1.72;
      head.castShadow = true;
      group.add(head);

      if (!isArcher) {
        const shield = new THREE.Mesh(
          new THREE.CircleGeometry(isKnight ? 0.42 : 0.38, 10),
          new THREE.MeshStandardMaterial({ color: 0x6b7280, roughness: 0.6, metalness: 0.25 })
        );
        shield.position.set(0.48, 1.15, 0.35);
        shield.rotation.y = Math.PI;
        shield.castShadow = true;
        group.add(shield);
      }

      if (isArcher) {
        const bow = new THREE.Mesh(
          new THREE.TorusGeometry(0.35, 0.06, 8, 16, Math.PI),
          new THREE.MeshStandardMaterial({ color: 0x5a3c24, roughness: 0.95 })
        );
        bow.position.set(-0.48, 1.25, 0.25);
        bow.rotation.z = Math.PI / 2;
        bow.castShadow = true;
        group.add(bow);
      } else {
        const weapon = new THREE.Mesh(
          new THREE.BoxGeometry(0.1, isKnight ? 1.1 : 0.95, 0.08),
          new THREE.MeshStandardMaterial({ color: 0x9ca3af, roughness: 0.35, metalness: 0.65 })
        );
        weapon.position.set(-0.45, 1.05, 0.2);
        weapon.castShadow = true;
        group.add(weapon);
      }

      group.position.set(x, 0, z);
      scene.add(group);

      const statsByType = {
        archer: { hp: 30, speed: 2.6, attack: 8, knock: 1.6, radius: 0.4, height: 1.9, fireRate: 1.25, preferredRange: 14 },
        foot: { hp: 60, speed: 3.1, attack: 12, knock: 3.2, radius: 0.45, height: 1.9, fireRate: 1.2, preferredRange: 1.8 },
        knight: { hp: 100, speed: 2.85, attack: 16, knock: 4.0, radius: 0.5, height: 2.0, fireRate: 1.0, preferredRange: 1.8 }
      };
      const s = statsByType[type] || statsByType.foot;

      const enemy = {
        mesh: group,
        velocity: new THREE.Vector3(),
        type,
        hp: s.hp,
        maxHp: s.hp,
        moveSpeed: s.speed,
        attackDamage: s.attack,
        knockStrength: s.knock,
        radius: s.radius,
        height: s.height,
        fireRate: s.fireRate,
        preferredRange: s.preferredRange,
        isDown: false,
        downTimer: 0,
        attackCooldown: 0,
        shootCooldown: 0,
        retargetTimer: 0,
        objectivePoint: null,
        id: Math.random().toString(16).slice(2)
      };

      enemies.push(enemy);
      return enemy;
    }

    function clearEnemies() {
      for (const e of enemies) {
        scene.remove(e.mesh);
      }
      enemies = [];
    }

    function clearProjectiles() {
      for (const p of projectiles) {
        scene.remove(p.mesh);
      }
      projectiles = [];
    }

    function spawnEnemiesForMap(mapId) {
      clearEnemies();

      clearProjectiles();

      if (mapId === 'village') {
        createEnemySoldier(10, -12);
        createEnemySoldier(-16, -8);
        createEnemySoldier(20, 10);
      } else if (mapId === 'bridge') {
        createEnemySoldier(-10, 6);
        createEnemySoldier(10, 6);
        createEnemySoldier(0, -18);
        createEnemySoldier(18, -10);
      } else {
        createEnemySoldier(-18, -10);
        createEnemySoldier(18, -10);
        createEnemySoldier(0, 0);
        createEnemySoldier(-10, 22);
      }
    }

    function getPlayerPosition2D() {
      const p = controls.getObject().position;
      return new THREE.Vector3(p.x, 0, p.z);
    }

    function applyEnemyKnock(enemy, impulse, knockChance) {
      enemy.velocity.add(impulse);

      const power = impulse.length();
      const chance = clamp(knockChance + (power - 4.0) * 0.08, 0, 0.85);
      if (!enemy.isDown && Math.random() < chance) {
        enemy.isDown = true;
        enemy.downTimer = 1.2 + Math.random() * 1.2;
        enemy.mesh.rotation.x = -Math.PI / 2;
        enemy.mesh.position.y = 0.25;
      }
    }

    function damageEnemy(enemy, amount) {
      enemy.hp = Math.max(0, enemy.hp - amount);
      if (enemy.hp <= 0 && !enemy.isDown) {
        enemy.isDown = true;
        enemy.downTimer = 2.5;
        enemy.mesh.rotation.x = -Math.PI / 2;
        enemy.mesh.position.y = 0.25;
      }
    }

    function killEnemy(enemy) {
      scene.remove(enemy.mesh);
      enemies = enemies.filter(e => e !== enemy);
      kills += 1;

      if (gameMode === 'custom' && respawnEnabled) {
        const delay = 1.2 + Math.random() * 1.8;
        respawnQueue.push({ t: delay });
      }
    }

    function chooseRespawnType() {
      const w = battleSpawnWeights;
      const total = Math.max(1, w.foot + w.archer + w.knight);
      let r = Math.random() * total;
      if ((r -= w.foot) <= 0) return 'foot';
      if ((r -= w.archer) <= 0) return 'archer';
      return 'knight';
    }

    function updateRespawns(dt) {
      if (!respawnEnabled) return;
      if (respawnQueue.length === 0) return;
      if (battleSpawnPoints.length === 0) return;
      if (endScreenEl.style.display !== 'none') return;

      for (let i = respawnQueue.length - 1; i >= 0; i--) {
        const item = respawnQueue[i];
        item.t -= dt;
        if (item.t > 0) continue;

        respawnQueue.splice(i, 1);

        if (enemies.length >= aliveCap) {
          respawnQueue.push({ t: 0.75 + Math.random() * 0.75 });
          continue;
        }

        const p = battleSpawnPoints[Math.floor(Math.random() * battleSpawnPoints.length)];
        const type = chooseRespawnType();
        createEnemy(type, p[0] + (Math.random() - 0.5) * 8, p[1] + (Math.random() - 0.5) * 8);
      }
    }

    function performMeleeHit(kind) {
      if (!controls.isLocked) return;

      const p = getPlayerPosition2D();
      const forward = new THREE.Vector3();
      controls.getDirection(forward);
      forward.y = 0;
      forward.normalize();

      const range = kind === 'kick' ? 1.6 : 2.2;
      const fovDot = kind === 'kick' ? 0.35 : 0.25;

      let best = null;
      let bestD = range;

      for (const e of enemies) {
        if (!e || !e.mesh) continue;
        if (e.isDown && e.downTimer > 0.2) continue;

        const ep = new THREE.Vector3(e.mesh.position.x, 0, e.mesh.position.z);
        const to = ep.clone().sub(p);
        const d = to.length();
        if (d > bestD) continue;
        to.normalize();
        const dot = forward.dot(to);
        if (dot < fovDot) continue;
        best = e;
        bestD = d;
      }

      if (!best) {
        showStatus(kind === 'kick' ? 'Kick (miss)' : 'Attack (miss)', 700);
        return;
      }

      const impulseStrength = kind === 'kick' ? 6.2 : 4.8;
      const impulse = forward.clone().multiplyScalar(impulseStrength);

      const dmg = kind === 'kick' ? 10 : 25;
      const knockChance = kind === 'kick' ? 0.35 : 0.18;

      damageEnemy(best, dmg);
      applyEnemyKnock(best, impulse, knockChance);

      if (best.hp <= 0) {
        killEnemy(best);
      }

      showStatus(kind === 'kick' ? 'Kick (hit)' : 'Attack (hit)', 700);
    }

    function applyPlayerKnock(direction, strength) {
      const knock = direction.clone().normalize().multiplyScalar(strength);
      playerExternalVelocity.add(knock);
    }

    function takePlayerDamage(amount, pushDir, pushStrength) {
      const dmg = isBlocking ? amount * 0.35 : amount;
      playerState.hp = Math.max(0, playerState.hp - dmg);

      const knock = isBlocking ? pushStrength * 0.55 : pushStrength;
      applyPlayerKnock(pushDir, knock);

      if (playerState.hp <= 0) {
        showEndScreen('Defeated', `You were defeated. Kills: ${kills}`);
      }
    }

    function createArrowProjectile(origin, dir, speed, damage) {
      const mesh = new THREE.Mesh(
        new THREE.CylinderGeometry(0.03, 0.03, 0.8, 8),
        new THREE.MeshStandardMaterial({ color: 0x9ca3af, roughness: 0.4, metalness: 0.4 })
      );
      mesh.rotation.z = Math.PI / 2;
      mesh.position.copy(origin);
      mesh.castShadow = true;
      scene.add(mesh);

      projectiles.push({
        mesh,
        velocity: dir.clone().normalize().multiplyScalar(speed),
        life: 6.0,
        damage
      });
    }

    function updateProjectiles(dt) {
      if (projectiles.length === 0) return;

      const playerPos = controls.getObject().position;

      for (let i = projectiles.length - 1; i >= 0; i--) {
        const p = projectiles[i];
        p.life -= dt;
        if (p.life <= 0) {
          scene.remove(p.mesh);
          projectiles.splice(i, 1);
          continue;
        }

        p.mesh.position.addScaledVector(p.velocity, dt);
        const yaw = Math.atan2(p.velocity.x, p.velocity.z);
        p.mesh.rotation.y = yaw;

        const dist = p.mesh.position.distanceTo(playerPos);
        if (dist < 1.0) {
          const pushDir = new THREE.Vector3(playerPos.x - p.mesh.position.x, 0, playerPos.z - p.mesh.position.z);
          takePlayerDamage(p.damage, pushDir, 2.0);
          scene.remove(p.mesh);
          projectiles.splice(i, 1);
          continue;
        }

        if (isCollidingCapsule(p.mesh.position, 0.15, 0.2)) {
          scene.remove(p.mesh);
          projectiles.splice(i, 1);
        }
      }
    }

    function createCapturePoint(x, z, name) {
      const ring = new THREE.Mesh(
        new THREE.RingGeometry(1.6, 2.1, 24),
        new THREE.MeshBasicMaterial({ color: 0xfacc15, transparent: true, opacity: 0.75, side: THREE.DoubleSide })
      );
      ring.rotation.x = -Math.PI / 2;
      ring.position.set(x, 0.05, z);
      scene.add(ring);

      const pole = new THREE.Mesh(
        new THREE.CylinderGeometry(0.06, 0.06, 2.6, 10),
        new THREE.MeshStandardMaterial({ color: 0x6b7280, roughness: 0.6, metalness: 0.2 })
      );
      pole.position.set(x, 1.3, z);
      pole.castShadow = true;
      scene.add(pole);

      const flag = new THREE.Mesh(
        new THREE.PlaneGeometry(1.0, 0.6),
        new THREE.MeshStandardMaterial({ color: 0xfacc15, roughness: 0.8, side: THREE.DoubleSide })
      );
      flag.position.set(x + 0.55, 1.7, z);
      flag.rotation.y = Math.PI / 2;
      flag.castShadow = true;
      scene.add(flag);

      const point = { name, x, z, radius: 6.0, progress: 0, owner: 'neutral', ring, flag };
      capturePoints.push(point);
      return point;
    }

    function updateCapturePoints(dt) {
      if (capturePoints.length === 0) return;

      const playerPos = getPlayerPosition2D();
      for (const p of capturePoints) {
        const center = new THREE.Vector3(p.x, 0, p.z);
        const playerIn = playerPos.distanceTo(center) <= p.radius;

        let enemyIn = false;
        for (const e of enemies) {
          const ep = new THREE.Vector3(e.mesh.position.x, 0, e.mesh.position.z);
          if (ep.distanceTo(center) <= p.radius) {
            enemyIn = true;
            break;
          }
        }

        const rate = 0.55;
        if (playerIn && !enemyIn) {
          p.progress = clamp(p.progress + rate * dt, -1, 1);
        } else if (!playerIn && enemyIn) {
          p.progress = clamp(p.progress - rate * dt, -1, 1);
        }

        if (p.progress >= 1) p.owner = 'player';
        else if (p.progress <= -1) p.owner = 'enemy';
        else p.owner = 'neutral';

        const col = p.owner === 'player' ? 0x22c55e : (p.owner === 'enemy' ? 0xef4444 : 0xfacc15);
        p.ring.material.color.setHex(col);
        p.flag.material.color.setHex(col);
      }

      if (winCondition === 'hold_5m') {
        const lostAny = capturePoints.some(p => p.owner !== 'player');
        if (lostAny) {
          showEndScreen('Defeated', `You lost an area. Kills: ${kills}`);
          return;
        }

        holdTimerSeconds = Math.max(0, holdTimerSeconds - dt);
        if (holdTimerSeconds <= 0) {
          showEndScreen('Victory', `You held all areas for 5 minutes. Kills: ${kills}`);
        }
      }
    }

    function checkWinConditions() {
      if (gameMode !== 'custom') return;
      if (playerState.hp <= 0) return;
      if (endScreenEl.style.display !== 'none') return;

      if (winCondition === 'capture_all') {
        const allOwned = capturePoints.length > 0 && capturePoints.every(p => p.owner === 'player');
        if (allOwned) {
          showEndScreen('Victory', `You captured all areas. Kills: ${kills}`);
        }
      } else if (winCondition === 'kills_800') {
        if (kills >= 800) {
          showEndScreen('Victory', `Kills reached ${kills}.`);
        }
      }
    }

    function updateEnemies(dt) {
      const playerPos = getPlayerPosition2D();

      const shouldPlayObjective = gameMode === 'custom' && capturePoints.length > 0;

      for (const e of enemies) {
        e.shootCooldown = Math.max(0, e.shootCooldown - dt);
        e.attackCooldown = Math.max(0, e.attackCooldown - dt);

        if (e.isDown) {
          e.downTimer -= dt;
          e.velocity.multiplyScalar(0.85);
          tryMoveWithCollision(e.mesh.position, e.velocity, dt, e.radius, e.height);

          if (e.downTimer <= 0) {
            e.isDown = false;
            e.mesh.rotation.x = 0;
            e.mesh.position.y = 0;
          }
          continue;
        }

        const ep = new THREE.Vector3(e.mesh.position.x, 0, e.mesh.position.z);
        const toPlayer = playerPos.clone().sub(ep);
        const distToPlayer = toPlayer.length();

        let targetPos = playerPos;
        let chasingPlayer = true;

        if (shouldPlayObjective && distToPlayer > 12) {
          chasingPlayer = false;
          e.retargetTimer -= dt;
          if (e.retargetTimer <= 0 || !e.objectivePoint) {
            e.retargetTimer = 1.4 + Math.random() * 1.6;
            let best = null;
            let bestD = Infinity;
            for (const p of capturePoints) {
              if (p.owner === 'enemy') continue;
              const d = ep.distanceTo(new THREE.Vector3(p.x, 0, p.z));
              if (d < bestD) {
                bestD = d;
                best = p;
              }
            }
            e.objectivePoint = best || capturePoints[0];
          }
          if (e.objectivePoint) {
            targetPos = new THREE.Vector3(e.objectivePoint.x, 0, e.objectivePoint.z);
          }
        }

        const toTarget = targetPos.clone().sub(ep);
        const dist = toTarget.length();
        const dir = dist > 0.0001 ? toTarget.clone().multiplyScalar(1 / dist) : new THREE.Vector3(0, 0, 1);

        let desired = new THREE.Vector3(0, 0, 0);
        if (e.type === 'archer') {
          const desiredDist = e.preferredRange;
          if (dist < desiredDist - 2) {
            desired = dir.clone().multiplyScalar(-e.moveSpeed);
          } else if (dist > desiredDist + 2) {
            desired = dir.clone().multiplyScalar(e.moveSpeed);
          }
        } else {
          desired = dir.clone().multiplyScalar(dist > 2.0 ? e.moveSpeed : 0.0);
        }

        e.velocity.lerp(desired, 0.9 * dt * 6);
        e.velocity.multiplyScalar(0.92);

        tryMoveWithCollision(e.mesh.position, e.velocity, dt, e.radius, e.height);
        e.mesh.position.y = 0;

        const yaw = Math.atan2(dir.x, dir.z);
        e.mesh.rotation.y = yaw;

        if (e.type === 'archer') {
          if (distToPlayer < 22 && distToPlayer > 6 && e.shootCooldown <= 0) {
            const origin = new THREE.Vector3(e.mesh.position.x, 1.4, e.mesh.position.z);
            const shotDir = new THREE.Vector3(playerPos.x - e.mesh.position.x, 0, playerPos.z - e.mesh.position.z).normalize();
            createArrowProjectile(origin, shotDir, 16.0, e.attackDamage);
            e.shootCooldown = e.fireRate;
          }
        } else {
          if (distToPlayer < 2.1 && e.attackCooldown <= 0) {
            const pushDir = playerPos.clone().sub(ep);
            pushDir.y = 0;
            takePlayerDamage(e.attackDamage, pushDir, e.knockStrength);
            e.attackCooldown = e.fireRate;
          }
        }
      }

      for (let i = 0; i < enemies.length; i++) {
        for (let j = i + 1; j < enemies.length; j++) {
          const a = enemies[i];
          const b = enemies[j];
          const ap = new THREE.Vector3(a.mesh.position.x, 0, a.mesh.position.z);
          const bp = new THREE.Vector3(b.mesh.position.x, 0, b.mesh.position.z);
          const d = ap.distanceTo(bp);
          if (d < 0.9 && d > 0.0001) {
            const push = ap.clone().sub(bp).multiplyScalar((0.9 - d) * 0.7);
            a.mesh.position.x += push.x * dt;
            a.mesh.position.z += push.z * dt;
            b.mesh.position.x -= push.x * dt;
            b.mesh.position.z -= push.z * dt;
          }
        }
      }
    }

    function createSwordPickup(x, z) {
      const group = new THREE.Group();
      const blade = new THREE.Mesh(
        new THREE.BoxGeometry(0.12, 1.2, 0.04),
        new THREE.MeshStandardMaterial({ color: 0xc7c7c7, roughness: 0.3, metalness: 0.9 })
      );
      blade.position.y = 0.8;
      blade.castShadow = true;
      group.add(blade);

      const handle = new THREE.Mesh(
        new THREE.CylinderGeometry(0.06, 0.06, 0.35, 10),
        new THREE.MeshStandardMaterial({ color: 0x2a1a12, roughness: 0.95 })
      );
      handle.position.y = 0.3;
      handle.castShadow = true;
      group.add(handle);

      const guard = new THREE.Mesh(
        new THREE.BoxGeometry(0.4, 0.06, 0.06),
        new THREE.MeshStandardMaterial({ color: 0x6b7280, roughness: 0.4, metalness: 0.6 })
      );
      guard.position.y = 0.52;
      guard.castShadow = true;
      group.add(guard);

      group.position.set(x, 0, z);
      group.rotation.x = -Math.PI / 2;
      scene.add(group);
      addInteractable(group, 'sword', 'Pick up sword');
      return group;
    }

    function createVillager(x, z) {
      const group = new THREE.Group();
      const body = new THREE.Mesh(
        new THREE.CapsuleGeometry(0.35, 0.8, 6, 10),
        new THREE.MeshStandardMaterial({ color: 0x8b5cf6, roughness: 0.85 })
      );
      body.position.y = 1.0;
      body.castShadow = true;
      body.receiveShadow = true;
      group.add(body);

      const head = new THREE.Mesh(
        new THREE.SphereGeometry(0.25, 12, 12),
        new THREE.MeshStandardMaterial({ color: 0xffd1a8, roughness: 0.9 })
      );
      head.position.y = 1.65;
      head.castShadow = true;
      group.add(head);

      group.position.set(x, 0, z);
      scene.add(group);
      addInteractable(group, 'villager', 'Tell villager to run');
      return group;
    }

    function createHorse(x, z) {
      const group = new THREE.Group();

      const body = new THREE.Mesh(
        new THREE.BoxGeometry(1.4, 0.9, 2.5),
        new THREE.MeshStandardMaterial({ color: 0x5b3a1e, roughness: 0.9 })
      );
      body.position.set(0, 0.9, 0);
      body.castShadow = true;
      body.receiveShadow = true;
      group.add(body);

      const neck = new THREE.Mesh(
        new THREE.BoxGeometry(0.55, 0.55, 0.9),
        new THREE.MeshStandardMaterial({ color: 0x5b3a1e, roughness: 0.9 })
      );
      neck.position.set(0, 1.2, 1.2);
      neck.rotation.x = -0.35;
      neck.castShadow = true;
      group.add(neck);

      const head = new THREE.Mesh(
        new THREE.BoxGeometry(0.45, 0.45, 0.6),
        new THREE.MeshStandardMaterial({ color: 0x4a2f18, roughness: 0.9 })
      );
      head.position.set(0, 1.1, 1.75);
      head.castShadow = true;
      group.add(head);

      for (const sx of [-0.45, 0.45]) {
        for (const sz of [-0.75, 0.75]) {
          const leg = new THREE.Mesh(
            new THREE.CylinderGeometry(0.12, 0.14, 0.9, 10),
            new THREE.MeshStandardMaterial({ color: 0x3a2415, roughness: 0.95 })
          );
          leg.position.set(sx, 0.45, sz);
          leg.castShadow = true;
          leg.receiveShadow = true;
          group.add(leg);
        }
      }

      group.position.set(x, 0, z);
      scene.add(group);
      addInteractable(group, 'horse', 'Ride horse');
      return group;
    }

    function addMapBorders(size, wallHeight = 3.5) {
      const half = size / 2;
      const t = 1.2;
      const y = wallHeight / 2;
      createWallBox(size, wallHeight, t, 0x3a3a3a, 0, y, -half);
      createWallBox(size, wallHeight, t, 0x3a3a3a, 0, y, half);
      createWallBox(t, wallHeight, size, 0x3a3a3a, -half, y, 0);
      createWallBox(t, wallHeight, size, 0x3a3a3a, half, y, 0);
    }

    function buildVillage() {
      clearWorld();

      currentMapId = 'village';

      scene.background = new THREE.Color(0x87b9e6);
      scene.fog = new THREE.Fog(0x87b9e6, 20, 90);

      const ambient = new THREE.AmbientLight(0xffffff, 0.6);
      scene.add(ambient);

      const sun = new THREE.DirectionalLight(0xffffff, 1.05);
      sun.position.set(30, 50, 20);
      sun.castShadow = true;
      sun.shadow.mapSize.width = 2048;
      sun.shadow.mapSize.height = 2048;
      sun.shadow.camera.left = -60;
      sun.shadow.camera.right = 60;
      sun.shadow.camera.top = 60;
      sun.shadow.camera.bottom = -60;
      sun.shadow.camera.near = 0.5;
      sun.shadow.camera.far = 200;
      scene.add(sun);

      createGround(120, 0x3f6b35);
      addMapBorders(120, 3.5);

      for (const p of [
        [-20, -10],
        [-5, -18],
        [18, -14],
        [22, 8],
        [-18, 16]
      ]) {
        createHouse(p[0], p[1]);
      }

      createFenceSegment(-6, -2, 18, true);
      createFenceSegment(-15, 7, 18, false);
      createFenceSegment(12, -6, 14, false);

      createCrate(-8, 0);
      createCrate(-10.3, 0.2, 0.9, 0.9, 0.9);
      createBarrel(-12, -2);
      createBarrel(8, -2);
      createBarrel(10, -1);

      for (const p of [
        [-30, -20],
        [-28, 22],
        [32, -18],
        [30, 22],
        [0, 26],
        [10, 20]
      ]) {
        createTree(p[0], p[1]);
      }

      createWallBox(28, 1.0, 10, 0x6b4f2a, 0, 0.5, 0);

      villager = createVillager(-6, 4);
      villagerTarget = new THREE.Vector3(-42, 0, 42);

      horse = createHorse(10, 6);
      createSwordPickup(3, -6);

      if (gameMode === 'story') {
        spawnEnemiesForMap(currentMapId);
      }

      camera.position.set(0, player.y, 34);
      controls.getObject().position.set(0, player.y, 34);

      showStatus('Map: Grayfield Village');
    }

    function buildBridge() {
      clearWorld();

      currentMapId = 'bridge';

      scene.background = new THREE.Color(0xa9c6ff);
      scene.fog = new THREE.Fog(0xa9c6ff, 30, 120);

      const ambient = new THREE.AmbientLight(0xffffff, 0.65);
      scene.add(ambient);

      const sun = new THREE.DirectionalLight(0xffffff, 1.0);
      sun.position.set(-40, 60, 10);
      sun.castShadow = true;
      sun.shadow.mapSize.width = 2048;
      sun.shadow.mapSize.height = 2048;
      sun.shadow.camera.left = -70;
      sun.shadow.camera.right = 70;
      sun.shadow.camera.top = 70;
      sun.shadow.camera.bottom = -70;
      sun.shadow.camera.near = 0.5;
      sun.shadow.camera.far = 240;
      scene.add(sun);

      createGround(160, 0x3d6a3a);

      const river = new THREE.Mesh(
        new THREE.PlaneGeometry(160, 24),
        new THREE.MeshStandardMaterial({ color: 0x1f5fa8, roughness: 0.25, metalness: 0.1 })
      );
      river.rotation.x = -Math.PI / 2;
      river.position.y = 0.02;
      scene.add(river);

      const bridge = new THREE.Mesh(
        new THREE.BoxGeometry(18, 1.2, 28),
        new THREE.MeshStandardMaterial({ color: 0x6b4f2a, roughness: 0.9 })
      );
      bridge.position.set(0, 0.6, 0);
      bridge.castShadow = true;
      bridge.receiveShadow = true;
      scene.add(bridge);
      addCollider(bridge);

      createWallBox(18, 1.2, 2.0, 0x3a2a1a, 0, 1.35, 13.5);
      createWallBox(18, 1.2, 2.0, 0x3a2a1a, 0, 1.35, -13.5);

      for (const px of [-36, -24, -12, 12, 24, 36]) {
        createTree(px, 26);
        createTree(px, -26);
      }

      createCrate(-18, 8);
      createCrate(-16.4, 8.2, 0.9, 0.9, 0.9);
      createBarrel(-15, 6);
      createBarrel(15, 6);
      createCrate(18, 10);
      createFenceSegment(0, 18, 24, true);

      addMapBorders(160, 4.0);

      villager = createVillager(-10, 18);
      villagerTarget = new THREE.Vector3(-60, 0, 55);

      horse = createHorse(12, 16);
      createSwordPickup(0, -10);

      if (gameMode === 'story') {
        spawnEnemiesForMap(currentMapId);
      }

      camera.position.set(0, player.y, 52);
      controls.getObject().position.set(0, player.y, 52);

      showStatus('Map: Riverrun Ford');
    }

    function buildFortress() {
      clearWorld();

      currentMapId = 'fortress';

      scene.background = new THREE.Color(0xb0bcc8);
      scene.fog = new THREE.Fog(0xb0bcc8, 25, 120);

      const ambient = new THREE.AmbientLight(0xffffff, 0.55);
      scene.add(ambient);

      const sun = new THREE.DirectionalLight(0xffffff, 1.0);
      sun.position.set(40, 60, -20);
      sun.castShadow = true;
      sun.shadow.mapSize.width = 2048;
      sun.shadow.mapSize.height = 2048;
      sun.shadow.camera.left = -70;
      sun.shadow.camera.right = 70;
      sun.shadow.camera.top = 70;
      sun.shadow.camera.bottom = -70;
      sun.shadow.camera.near = 0.5;
      sun.shadow.camera.far = 260;
      scene.add(sun);

      createGround(140, 0x4b4f55);

      const wallH = 6;
      const wallT = 2.2;
      const half = 70;

      createWallBox(140, wallH, wallT, 0x61656b, 0, wallH / 2, -half);
      createWallBox(140, wallH, wallT, 0x61656b, 0, wallH / 2, half);
      createWallBox(wallT, wallH, 140, 0x61656b, -half, wallH / 2, 0);
      createWallBox(wallT, wallH, 140, 0x61656b, half, wallH / 2, 0);

      const gate = new THREE.Mesh(
        new THREE.BoxGeometry(10, 5.2, 2.0),
        new THREE.MeshStandardMaterial({ color: 0x3a2a1a, roughness: 0.85 })
      );
      gate.position.set(0, 2.6, -half + 1.1);
      gate.castShadow = true;
      gate.receiveShadow = true;
      scene.add(gate);
      addCollider(gate);

      for (const p of [
        [-48, -48],
        [48, -48],
        [-48, 48],
        [48, 48]
      ]) {
        createWallBox(10, 10, 10, 0x61656b, p[0], 5, p[1]);
      }

      createWallBox(20, 1.2, 20, 0x6b4f2a, 0, 0.6, 12);
      createWallBox(12, 2.0, 12, 0x6b4f2a, -26, 1.0, -18);
      createWallBox(12, 2.0, 12, 0x6b4f2a, 26, 1.0, -18);

      createCrate(6, 14, 1.2, 1.2, 1.2);
      createCrate(8, 14.2, 1.0, 1.0, 1.0);
      createBarrel(-6, 14);
      createBarrel(-8, 14);
      createCrate(-12, -2, 1.4, 1.0, 1.4);
      createCrate(12, -2, 1.4, 1.0, 1.4);

      villager = createVillager(-10, 10);
      villagerTarget = new THREE.Vector3(-55, 0, 55);

      horse = createHorse(12, 10);
      createSwordPickup(0, -10);

      if (gameMode === 'story') {
        spawnEnemiesForMap(currentMapId);
      }

      camera.position.set(0, player.y, 40);
      controls.getObject().position.set(0, player.y, 40);

      showStatus('Map: Blackgate Courtyard');
    }

    function buildSelectedMap() {
      const m = mapSelect.value;
      if (m === 'village') buildVillage();
      else if (m === 'bridge') buildBridge();
      else buildFortress();
    }

    function buildMapById(id) {
      if (id === 'village') buildVillage();
      else if (id === 'bridge') buildBridge();
      else buildFortress();
    }

    function initThree() {
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      gameRoot.innerHTML = '';
      gameRoot.appendChild(renderer.domElement);

      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 500);
      camera.position.set(0, player.y, 20);

      controls = new PointerLockControls(camera, renderer.domElement);
      scene.add(controls.getObject());

      clock = new THREE.Clock();

      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      document.addEventListener('contextmenu', (e) => e.preventDefault());

      document.addEventListener('keydown', (e) => {
        keys[e.key.toLowerCase()] = true;
        if (e.key === 'Escape') {
          showPrompt('');
        }
      });

      document.addEventListener('keyup', (e) => {
        keys[e.key.toLowerCase()] = false;
      });

      renderer.domElement.addEventListener('mousedown', (e) => {
        if (e.button === 0) {
          tryAttack();
        } else if (e.button === 2) {
          isBlocking = true;
          showStatus('Blocking');
        }
      });

      renderer.domElement.addEventListener('mouseup', (e) => {
        if (e.button === 2) {
          isBlocking = false;
          showStatus('');
        }
      });

      document.addEventListener('keydown', (e) => {
        if (e.key.toLowerCase() === 'f') {
          tryKick();
        }
        if (e.key.toLowerCase() === 'e') {
          tryInteract();
        }
      });

      controls.addEventListener('lock', () => {
        menu.style.display = 'none';
        hud.style.display = 'block';
        cornerControlsEl.style.display = 'block';
        hpEl.style.display = 'block';
        updateHud();
        showStatus('');
      });

      controls.addEventListener('unlock', () => {
        hud.style.display = 'none';
        cornerControlsEl.style.display = 'none';
        hpEl.style.display = 'none';
        objectiveEl.style.display = 'none';
        menu.style.display = 'flex';
        showPrompt('');
      });

      animate();
    }

    function playerBoxAt(pos) {
      const size = new THREE.Vector3(player.radius * 2, player.height, player.radius * 2);
      const center = new THREE.Vector3(pos.x, player.height / 2, pos.z);
      return new THREE.Box3().setFromCenterAndSize(center, size);
    }

    function isColliding(pos) {
      const pBox = playerBoxAt(pos);
      for (const c of colliders) {
        if (c.box.intersectsBox(pBox)) return true;
      }
      return false;
    }

    function movePlayer(dt) {
      const speed = isMounted ? player.mountedSpeed : player.walkSpeed;

      const forward = new THREE.Vector3();
      controls.getDirection(forward);
      forward.y = 0;
      forward.normalize();

      const right = new THREE.Vector3().crossVectors(forward, new THREE.Vector3(0, 1, 0)).normalize();

      const dir = new THREE.Vector3(0, 0, 0);
      if (keys['w']) dir.add(forward);
      if (keys['s']) dir.add(forward.clone().multiplyScalar(-1));
      if (keys['d']) dir.add(right);
      if (keys['a']) dir.add(right.clone().multiplyScalar(-1));

      if (dir.lengthSq() === 0) return;
      dir.normalize();

      const obj = controls.getObject();
      const prev = obj.position.clone();

      playerExternalVelocity.multiplyScalar(0.88);
      obj.position.x += playerExternalVelocity.x * dt;
      obj.position.z += playerExternalVelocity.z * dt;

      if (isColliding(obj.position)) {
        obj.position.copy(prev);
        playerExternalVelocity.multiplyScalar(-0.2);
      }

      obj.position.x += dir.x * speed * dt;
      obj.position.z += dir.z * speed * dt;

      obj.position.y = player.y;

      if (isColliding(obj.position)) {
        obj.position.copy(prev);
      }
    }

    function nearestInteractable(maxDist = 2.2) {
      let best = null;
      let bestD = maxDist;
      const pos = controls.getObject().position;
      for (const it of interactables) {
        const d = pos.distanceTo(it.mesh.position);
        if (d < bestD) {
          best = it;
          bestD = d;
        }
      }
      return best;
    }

    function updatePrompt() {
      const it = nearestInteractable(2.2);
      if (!it) {
        showPrompt('');
        return;
      }
      if (it.type === 'sword' && hasSword) {
        showPrompt('');
        return;
      }
      if (it.type === 'horse') {
        showPrompt(isMounted ? 'Press E to dismount' : 'Press E to ride horse');
        return;
      }
      if (it.type === 'villager') {
        showPrompt('Press E to tell villager where to go');
        return;
      }
      showPrompt(`Press E to ${it.label}`);
    }

    function tryInteract() {
      if (!controls.isLocked) return;
      const it = nearestInteractable(2.2);
      if (!it) return;

      if (it.type === 'sword') {
        if (hasSword) return;
        hasSword = true;
        scene.remove(it.mesh);
        interactables = interactables.filter(x => x !== it);
        showStatus('Picked up sword');
        return;
      }

      if (it.type === 'villager') {
        if (!villager || !villagerTarget) return;
        showStatus('Villager: Run to safety!');
        return;
      }

      if (it.type === 'horse') {
        isMounted = !isMounted;
        showStatus(isMounted ? 'Mounted horse' : 'Dismounted');
        return;
      }
    }

    function tryAttack() {
      if (!controls.isLocked) return;
      const now = performance.now();
      if (now - lastAttackTime < 420) return;
      lastAttackTime = now;
      if (!hasSword) {
        showStatus('No weapon. Press E near the sword.');
        return;
      }
      if (isBlocking) {
        showStatus('Cannot attack while blocking');
        return;
      }
      performMeleeHit('sword');
    }

    function tryKick() {
      if (!controls.isLocked) return;
      const now = performance.now();
      if (now - lastKickTime < 650) return;
      lastKickTime = now;
      performMeleeHit('kick');
    }

    function updateHorseFollow(dt) {
      if (!horse) return;
      if (!isMounted) return;

      const obj = controls.getObject();
      const target = new THREE.Vector3(obj.position.x, 0, obj.position.z);

      const horsePos = horse.position.clone();
      const to = target.clone().sub(horsePos);
      const dist = to.length();

      if (dist < 0.01) return;

      const maxStep = Math.min(dist, 8.0 * dt);
      to.normalize();
      horse.position.x += to.x * maxStep;
      horse.position.z += to.z * maxStep;

      const facing = new THREE.Vector3(to.x, 0, to.z);
      const yaw = Math.atan2(facing.x, facing.z);
      horse.rotation.y = yaw;
    }

    function updateVillager(dt) {
      if (!villager || !villagerTarget) return;

      const pos = villager.position.clone();
      const to = villagerTarget.clone().sub(pos);
      const d = to.length();
      if (d < 0.2) return;

      const step = Math.min(d, 2.6 * dt);
      to.normalize();
      villager.position.x += to.x * step;
      villager.position.z += to.z * step;

      const yaw = Math.atan2(to.x, to.z);
      villager.rotation.y = yaw;
    }

    function animate() {
      requestAnimationFrame(animate);

      if (!scene || !camera || !renderer) return;

      const dt = Math.min(clock.getDelta(), 0.03);

      if (controls.isLocked) {
        movePlayer(dt);
        updateColliders();
        updatePrompt();
        updateHorseFollow(dt);
        updateVillager(dt);
        updateEnemies(dt);
        updateProjectiles(dt);
        if (gameMode === 'custom') {
          updateCapturePoints(dt);
          checkWinConditions();
          updateRespawns(dt);
        }
        updateHud();
      }

      renderer.render(scene, camera);
    }

    startBtn.addEventListener('click', async () => {
      if (!renderer) {
        initThree();
      }

      gameMode = 'story';
      winCondition = 'capture_all';
      buildSelectedMap();
      controls.lock();
    });

    function clampInputNumber(el, max) {
      const v = Number(el.value);
      if (!Number.isFinite(v)) {
        el.value = '0';
        return;
      }
      el.value = String(clamp(Math.floor(v), 0, max));
    }

    countFootEl.addEventListener('change', () => clampInputNumber(countFootEl, 200));
    countArcherEl.addEventListener('change', () => clampInputNumber(countArcherEl, 100));
    countKnightEl.addEventListener('change', () => clampInputNumber(countKnightEl, 40));

    startCustomBtn.addEventListener('click', async () => {
      if (!renderer) {
        initThree();
      }

      clampInputNumber(countFootEl, 200);
      clampInputNumber(countArcherEl, 100);
      clampInputNumber(countKnightEl, 40);

      gameMode = 'custom';
      winCondition = winConditionEl.value;

      respawnEnabled = winCondition === 'kills_800';

      mapSelect.value = customMapSelect.value;
      buildMapById(customMapSelect.value);

      const spawn = {
        village: [
          [-40, -30], [-30, -20], [-20, -30],
          [30, -20], [40, -30], [26, 24],
          [-30, 26], [0, -34]
        ],
        bridge: [
          [-60, -40], [-40, -30], [40, -30], [60, -40],
          [-30, 30], [30, 30], [0, -30]
        ],
        fortress: [
          [-50, -40], [50, -40], [-50, 40], [50, 40],
          [0, -48], [0, 48], [-30, 0], [30, 0]
        ]
      }[customMapSelect.value] || [[20, -20], [-20, -20], [20, 20], [-20, 20]];

      battleSpawnPoints = spawn;

      enemies = [];
      projectiles = [];
      kills = 0;
      holdTimerSeconds = 300;
      playerState.hp = playerState.maxHp;

      const footCount = Number(countFootEl.value);
      const archerCount = Number(countArcherEl.value);
      const knightCount = Number(countKnightEl.value);

      aliveCap = Math.max(1, footCount + archerCount + knightCount);
      battleSpawnWeights = {
        foot: Math.max(1, footCount),
        archer: Math.max(1, archerCount),
        knight: Math.max(1, knightCount)
      };

      let idx = 0;
      for (let i = 0; i < footCount; i++) {
        const p = spawn[idx % spawn.length];
        createEnemy('foot', p[0] + (Math.random() - 0.5) * 6, p[1] + (Math.random() - 0.5) * 6);
        idx++;
      }
      for (let i = 0; i < archerCount; i++) {
        const p = spawn[idx % spawn.length];
        createEnemy('archer', p[0] + (Math.random() - 0.5) * 8, p[1] + (Math.random() - 0.5) * 8);
        idx++;
      }
      for (let i = 0; i < knightCount; i++) {
        const p = spawn[idx % spawn.length];
        createEnemy('knight', p[0] + (Math.random() - 0.5) * 8, p[1] + (Math.random() - 0.5) * 8);
        idx++;
      }

      if (customMapSelect.value === 'village') {
        createCapturePoint(-22, -8, 'Barn');
        createCapturePoint(0, 0, 'Well');
        createCapturePoint(22, 12, 'Road');
      } else if (customMapSelect.value === 'bridge') {
        createCapturePoint(-18, 0, 'West');
        createCapturePoint(0, 0, 'Bridge');
        createCapturePoint(18, 0, 'East');
      } else {
        createCapturePoint(-20, -10, 'Yard');
        createCapturePoint(0, 10, 'Center');
        createCapturePoint(20, -10, 'Gate');
      }

      if (winCondition === 'hold_5m') {
        for (const p of capturePoints) {
          p.owner = 'player';
          p.progress = 1;
          const col = 0x22c55e;
          p.ring.material.color.setHex(col);
          p.flag.material.color.setHex(col);
        }
        holdTimerSeconds = 300;
      }

      customBattleCard.style.display = 'none';
      controls.lock();
    });
  </script>
</body>
</html>
