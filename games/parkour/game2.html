<!DOCTYPE html>
<html>
<head>
  <title>Parkour</title>
  <style>
    body {
      background: #0a0a0a;
      margin: 0;
      padding: 0;
      overflow: hidden; /* 防止出现滚动条 */
      text-align: center;
    }
    canvas#game {
      display: block;
      width: 100vw;
      height: 100vh;
      background:
        radial-gradient(circle at 18% 82%, rgba(255, 140, 0, 0.35), rgba(0,0,0,0) 55%),
        radial-gradient(circle at 78% 28%, rgba(255, 60, 0, 0.25), rgba(0,0,0,0) 60%),
        linear-gradient(180deg, #1a0f0b 0%, #050203 100%),
        repeating-linear-gradient(0deg, rgba(0,0,0,0.45) 0 2px, rgba(0,0,0,0) 2px 64px),
        repeating-linear-gradient(90deg, rgba(0,0,0,0.42) 0 2px, rgba(0,0,0,0) 2px 140px);
      cursor: default;
    }
  </style>
</head>
<body>
  <h2 style="margin:10px; font-family:sans-serif;">Parkour: Arrows/WASD to move, Space to jump, R to restart</h2>
  <canvas id="game"></canvas>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');

    let screen = 'play';

    function resize() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      if (screen === 'shop') rebuildShopStands();
    }
    window.addEventListener('resize', resize);
    resize();

    // Input
    const keys = new Set();
    window.addEventListener('keydown', (e) => {
      keys.add(e.key.toLowerCase());
      if ([' ', 'arrowup'].includes(e.key.toLowerCase())) e.preventDefault();
    });
    window.addEventListener('keyup', (e) => keys.delete(e.key.toLowerCase()));

    // World
    const gravity = 2000; // px/s^2 (harder)
    const moveAccel = 2200; // px/s^2
    const maxSpeedX = 400; // px/s
    const frictionGround = 1400; // px/s^2
    const jumpSpeed = 660; // px/s (slightly lower, harder)
    const coyoteTime = 0.1;
    const jumpBufferTime = 0.12;

    const urlParams = new URLSearchParams(window.location.search);
    const modeParam = urlParams.get('mode');
    let gameMode = (modeParam || 'classic').toLowerCase();
    let noCheckpointsMode = gameMode === 'nocp' || gameMode === 'no-checkpoint' || gameMode === 'ncp';
    let modeLabel = noCheckpointsMode ? 'No-Checkpoint' : 'Checkpoints';
    screen = modeParam ? 'play' : 'menu';

    const COINS_KEY = 'parkour_coins';
    let coins = 0;
    try {
      coins = parseInt(localStorage.getItem(COINS_KEY) || '0', 10) || 0;
    } catch (e) {
      coins = 0;
    }

    const SKINS = [
      { id: 'none', name: 'Nothing', price: 0, type: 'base', body: '#111', accent: '#3b82f6' },
      { id: 'ninja', name: 'Ninja', price: 900, type: 'power', body: '#050505', accent: '#ef4444' },
      { id: 'monks', name: 'Monks', price: 950, type: 'power', body: '#f8fafc', accent: '#f59e0b' },
      { id: 'iron-golem', name: 'Iron Golem', price: 1100, type: 'power', body: '#374151', accent: '#1d4ed8' },
      { id: 'knight', name: 'Knight', price: 450, type: 'cosmetic', body: '#9ca3af', accent: '#374151' },
      { id: 'prince', name: 'Prince', price: 550, type: 'cosmetic', body: '#fbbf24', accent: '#b45309' },
      { id: 'ember', name: 'Ember', price: 400, type: 'cosmetic', body: '#fb7185', accent: '#f97316' },
      { id: 'frost', name: 'Frost', price: 400, type: 'cosmetic', body: '#60a5fa', accent: '#22d3ee' },
    ];
    const UNLOCKED_SKINS_KEY = 'parkour_unlockedSkins';
    const SELECTED_SKIN_KEY = 'parkour_selectedSkin';
    let unlockedSkins = new Set(['none']);
    let selectedSkinId = 'none';
    try {
      const raw = JSON.parse(localStorage.getItem(UNLOCKED_SKINS_KEY) || '[]');
      if (Array.isArray(raw)) {
        for (const id of raw) if (typeof id === 'string') unlockedSkins.add(id);
      }
      const sel = localStorage.getItem(SELECTED_SKIN_KEY);
      if (sel) selectedSkinId = sel;
    } catch (e) {}
    function getSkin(id) { return SKINS.find(s => s.id === id) || SKINS[0]; }
    function isSkinUnlocked(id) { return unlockedSkins.has(id); }
    function saveSkins() {
      try {
        localStorage.setItem(UNLOCKED_SKINS_KEY, JSON.stringify(Array.from(unlockedSkins)));
        localStorage.setItem(SELECTED_SKIN_KEY, selectedSkinId);
      } catch (e) {}
    }
    if (!getSkin(selectedSkinId)) selectedSkinId = 'none';
    if (!isSkinUnlocked(selectedSkinId)) selectedSkinId = 'none';
    saveSkins();

    function setMode(mode) {
      gameMode = (mode || 'classic').toLowerCase();
      noCheckpointsMode = gameMode === 'nocp' || gameMode === 'no-checkpoint' || gameMode === 'ncp';
      modeLabel = noCheckpointsMode ? 'No-Checkpoint' : 'Checkpoints';

      bestScore = 0;
      bestDistance = 0;
      bestSaved = false;
      try {
        if (noCheckpointsMode) {
          bestScore = parseInt(localStorage.getItem(BEST_SCORE_KEY) || '0', 10) || 0;
          bestDistance = parseInt(localStorage.getItem(BEST_DISTANCE_KEY) || '0', 10) || 0;
        }
      } catch (e) {
        bestScore = 0;
        bestDistance = 0;
      }
      bestDistanceStart = bestDistance;
      bestDistanceBeaten = false;
    }

    let score = 0;
    let nonstopForwardTime = 0;
    let scoreTick = 0;
    let bestScore = 0;
    let bestDistance = 0;
    let bestSaved = false;
    let bestDistanceStart = 0;
    let bestDistanceBeaten = false;
    let comboActive = false;
    let comboAnimTime = 0;
    let bestDistAnimTime = 0;
    const comboAnimDuration = 0.8;
    const bestDistAnimDuration = 0.9;
    const BEST_SCORE_KEY = 'parkour_nocp_bestScore';
    const BEST_DISTANCE_KEY = 'parkour_nocp_bestDistance';
    setMode(gameMode);

    const player = { x: 60, y: 0, w: 40, h: 50, vx: 0, vy: 0, onGround: false, color: '#111' };
    let facing = 1;
    let jumpsLeft = 1;
    let hasDoubleJump = false;
    let doubleJumpTimer = 0; // seconds remaining when active
    let jumpHeld = false; // for edge detection
    let teleportHeld = false;
    let escapeHeld = false;
    let teleportCooldown = 0;
    let teleportFxTime = 0;
    const teleportFxDuration = 0.22;
    let teleportFrom = { x: 0, y: 0 };
    let teleportTo = { x: 0, y: 0 };
    let golemLives = 4;
    let golemInvuln = 0;
    let golemHitFlash = 0;
    let shopMessage = '';
    let shopMessageTime = 0;
    let coyoteTimer = 0;
    let jumpBufferTimer = 0;

    const menuZones = [];
    const shopStands = [];
    let interactLatch = 0;

    function saveCoins() {
      try { localStorage.setItem(COINS_KEY, String(coins)); } catch (e) {}
    }

    function addCoins(n) {
      if (!n) return;
      coins += n;
      if (coins < 0) coins = 0;
      saveCoins();
    }

    function rebuildShopStands() {
      shopStands.length = 0;
      const items = SKINS;
      const h = canvas.height;
      const baseY = h - 40;
      let x = 140;
      for (const s of items) {
        shopStands.push({
          skinId: s.id,
          x,
          y: baseY - 92,
          w: 160,
          h: 72,
        });
        x += 220;
      }
    }

    // Procedural infinite level
    function ground(y) { return { x: -1e6, y, w: 2e6, h: 40, type: 'ground' }; }
    let platforms = [];
    let hazards = [];
    let checkpoints = [];
    let powerups = []; // double-jump powerups
    let nextSpawnX = 0;
    let lastCheckpoint = { x: 60, y: 0 };
    let maxReachedX = 0;
    let chunksSpawned = 0;
    let checkpointFlashTime = 0; // seconds for 'checkpoint saved' flash

    function resetWorld() {
      platforms = [];
      hazards = [];
      checkpoints = [];
      powerups = [];
      nextSpawnX = 0;
      chunksSpawned = 0;
      const h = canvas.height;
      // Infinite ground band
      platforms.push(ground(h - 40));
      // Seed a few starting platforms
      spawnChunk();
      spawnChunk();
    }

    function difficultyAt(x) {
      // Increase from 0 -> 1 as distance grows (faster ramp)
      return Math.min(1, x / 3000);
    }

    function spawnChunk() {
      const h = canvas.height;
      const baseY = h - 40;
      const d = difficultyAt(nextSpawnX);
      const chunkW = 800; // generate about one screen at a time
      let x = nextSpawnX + 100;
      let cursorY = baseY - 140;
      while (x < nextSpawnX + chunkW) {
        // Platform sizes/gaps scale with difficulty
        const platW = Math.max(70, 210 - Math.floor(150 * d) + Math.floor(Math.random() * 40));
        const gap = Math.min(520, 260 + Math.floor(260 * d) + Math.floor(Math.random() * 160));
        // Vary height a bit
        const dy = (Math.random() - 0.5) * (120 + 120 * d);
        cursorY = Math.min(baseY - 80, Math.max(baseY - 360, cursorY + dy));
        const plat = { x, y: cursorY, w: platW, h: 20, type: 'plat' };
        platforms.push(plat);
        // Occasionally add a hazard between platforms on ground
        if (Math.random() < 0.5 + 0.5 * d) {
          const hzW = 40 + Math.floor(Math.random() * 60);
          hazards.push({ x: x + platW + (gap - hzW) / 2, y: baseY - 20, w: hzW, h: 20 });
        }
        // Occasionally add a powerup on top of a platform
        if (Math.random() < 0.18 + 0.25 * d) {
          powerups.push({ x: plat.x + Math.floor(plat.w/2) - 10, y: plat.y - 20, w: 20, h: 20, type: 'double' });
        }
        x += platW + gap;
      }
      // Add a checkpoint less frequently (every 3 chunks)
      const cpX = nextSpawnX + chunkW - 60;
      chunksSpawned++;
      if (!noCheckpointsMode && chunksSpawned % 3 === 0) {
        checkpoints.push({ x: cpX, y: baseY - 100, w: 16, h: 60 });
      }
      nextSpawnX += chunkW;
    }

    function ensureWorldAhead() {
      while (nextSpawnX < camera.x + canvas.width * 2) {
        spawnChunk();
      }
    }

    // Camera
    const camera = { x: 0, y: 0 };

    let t = 0;
    let shakeTime = 0;
    let shakeStrength = 0;
    const particles = [];
    const trail = [];

    function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }
    function lerp(a, b, t) { return a + (b - a) * t; }
    function rand(a, b) { return a + Math.random() * (b - a); }
    function hexToRgb(hex) {
      const h = hex.replace('#', '');
      const n = parseInt(h.length === 3 ? h.split('').map(c => c + c).join('') : h, 16);
      return { r: (n >> 16) & 255, g: (n >> 8) & 255, b: n & 255 };
    }
    function rgba(hex, a) {
      const c = hexToRgb(hex);
      return `rgba(${c.r},${c.g},${c.b},${a})`;
    }

    function worldToScreenX(x) { return Math.floor(x - camera.x); }
    function worldToScreenY(y) { return Math.floor(y - camera.y); }

    function roundRectPath(x, y, w, h, r) {
      const rr = Math.min(r, w / 2, h / 2);
      ctx.beginPath();
      ctx.moveTo(x + rr, y);
      ctx.arcTo(x + w, y, x + w, y + h, rr);
      ctx.arcTo(x + w, y + h, x, y + h, rr);
      ctx.arcTo(x, y + h, x, y, rr);
      ctx.arcTo(x, y, x + w, y, rr);
      ctx.closePath();
    }

    function spawnParticles(type, x, y, amount) {
      const base = type === 'power' ? '#06b6d4' : (type === 'land' ? '#6b7280' : '#ffffff');
      for (let i = 0; i < amount; i++) {
        const ang = rand(-Math.PI, 0);
        const spd = type === 'power' ? rand(80, 190) : (type === 'land' ? rand(140, 360) : rand(100, 260));
        const vx = Math.cos(ang) * spd * rand(0.5, 1.2);
        const vy = Math.sin(ang) * spd * rand(0.4, 1.1);
        const ttl = type === 'power' ? rand(0.5, 1.2) : (type === 'land' ? rand(0.3, 0.7) : rand(0.25, 0.6));
        particles.push({ x, y, vx, vy, life: ttl, ttl, size: rand(2, type === 'land' ? 6 : 4), color: base, gravity: type === 'power' ? -80 : 900, drag: type === 'power' ? 0.88 : 0.82 });
      }
    }

    function updateParticles(dt) {
      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.life -= dt;
        if (p.life <= 0) { particles.splice(i, 1); continue; }
        p.vx *= Math.pow(p.drag, dt * 60);
        p.vy *= Math.pow(p.drag, dt * 60);
        p.vy += p.gravity * dt;
        p.x += p.vx * dt;
        p.y += p.vy * dt;
      }
    }

    function rectsOverlap(a, b) {
      return !(a.x + a.w <= b.x || a.x >= b.x + b.w || a.y + a.h <= b.y || a.y >= b.y + b.h);
    }

    function resolveCollisions(p, dt) {
      p.onGround = false;
      // Sweep horizontally then vertically
      p.x += p.vx * dt;
      for (const s of platforms) {
        if (!rectsOverlap(p, s)) continue;
        if (p.vx > 0) {
          p.x = s.x - p.w;
        } else if (p.vx < 0) {
          p.x = s.x + s.w;
        }
        p.vx = 0;
      }
      p.y += p.vy * dt;
      for (const s of platforms) {
        if (!rectsOverlap(p, s)) continue;
        if (p.vy > 0) {
          p.y = s.y - p.h;
          p.vy = 0;
          p.onGround = true;
        } else if (p.vy < 0) {
          p.y = s.y + s.h;
          p.vy = 0;
        }
      }
    }

    let gameOver = false;
    let deathTimer = 0;
    const deathDuration = 0.9;
    let deathPieces = [];
    let deathCamX = 0;
    let deathCamY = 0;

    function triggerDeath() {
      if (gameOver) return;
      gameOver = true;
      deathTimer = 0;
      deathCamX = camera.x;
      deathCamY = camera.y;
      deathPieces = [];
      const cols = 6;
      const rows = 7;
      const pw = player.w / cols;
      const ph = player.h / rows;
      for (let cy = 0; cy < rows; cy++) {
        for (let cx = 0; cx < cols; cx++) {
          const px = player.x + cx * pw;
          const py = player.y + cy * ph;
          const dx = (cx - (cols - 1) / 2) / ((cols - 1) / 2);
          const dy = (cy - (rows - 1) / 2) / ((rows - 1) / 2);
          const spd = rand(220, 620);
          deathPieces.push({
            x: px,
            y: py,
            w: pw,
            h: ph,
            vx: dx * spd + rand(-120, 120),
            vy: dy * spd + rand(-520, -220),
            rot: rand(-1.6, 1.6),
            vr: rand(-7, 7),
          });
        }
      }
      spawnParticles('land', player.x + player.w * 0.5, player.y + player.h * 0.5, 36);
      shakeTime = 0.18;
      shakeStrength = Math.max(shakeStrength, 6);
    }

    function updateDeath(dt) {
      deathTimer += dt;
      for (const p of deathPieces) {
        p.vy += 2200 * dt;
        p.vx *= Math.pow(0.92, dt * 60);
        p.vy *= Math.pow(0.92, dt * 60);
        p.x += p.vx * dt;
        p.y += p.vy * dt;
        p.rot += p.vr * dt;
      }
      camera.x = deathCamX;
      camera.y = deathCamY;
    }

    function hardReset() {
      // Full reset back to start
      lastCheckpoint = { x: 60, y: 0 };
      maxReachedX = 0;
      player.x = lastCheckpoint.x; player.y = lastCheckpoint.y; player.vx = 0; player.vy = 0; player.onGround = false;
      gameOver = false;
      deathTimer = 0;
      deathPieces = [];
      score = 0;
      nonstopForwardTime = 0;
      scoreTick = 0;
      bestSaved = false;
      bestDistanceStart = bestDistance;
      bestDistanceBeaten = false;
      comboActive = false;
      comboAnimTime = 0;
      bestDistAnimTime = 0;
      teleportCooldown = 0;
      teleportFxTime = 0;
      golemLives = 4;
      golemInvuln = 0;
      golemHitFlash = 0;
      shopMessage = '';
      shopMessageTime = 0;
      hasDoubleJump = false; doubleJumpTimer = 0; jumpsLeft = 1; jumpHeld = false; checkpointFlashTime = 0;
      coyoteTimer = 0; jumpBufferTimer = 0;
      resetWorld();
    }

    function respawnAtCheckpoint() {
      player.x = lastCheckpoint.x;
      player.y = lastCheckpoint.y;
      player.vx = 0; player.vy = 0; player.onGround = false;
      gameOver = false; jumpHeld = false; // don't trigger jump immediately
      deathTimer = 0;
      deathPieces = [];
      nonstopForwardTime = 0;
      scoreTick = 0;
      comboActive = false;
      comboAnimTime = 0;
      bestDistAnimTime = 0;
      teleportCooldown = 0;
      teleportFxTime = 0;
      golemLives = 4;
      golemInvuln = 0;
      golemHitFlash = 0;
      coyoteTimer = 0; jumpBufferTimer = 0;
    }

    function setupHubWorld() {
      platforms = [];
      hazards = [];
      checkpoints = [];
      powerups = [];
      nextSpawnX = 0;
      chunksSpawned = 0;
      menuZones.length = 0;
      const h = canvas.height;
      const baseY = h - 40;
      platforms.push(ground(baseY));
      camera.x = 0;
      camera.y = 0;
    }

    function enterMenu() {
      screen = 'menu';
      setMode('classic');
      setupHubWorld();
      shopStands.length = 0;
      const h = canvas.height;
      const baseY = h - 40;
      menuZones.push({ id: 'playClassic', label: 'PLAY\n(Checkpoints)', x: 220, y: baseY - 92, w: 180, h: 72 });
      menuZones.push({ id: 'playNoCP', label: 'PLAY\n(No-Checkpoint)', x: 430, y: baseY - 92, w: 210, h: 72 });
      menuZones.push({ id: 'shop', label: 'SHOP', x: 670, y: baseY - 92, w: 150, h: 72 });
      player.x = 140;
      player.y = baseY - player.h - 2;
      player.vx = 0;
      player.vy = 0;
      jumpsLeft = 1;
      hasDoubleJump = false;
      doubleJumpTimer = 0;
      coyoteTimer = 0;
      jumpBufferTimer = 0;
      gameOver = false;
      deathTimer = 0;
      deathPieces = [];
      interactLatch = 0;
      golemLives = 4;
      golemInvuln = 0;
      golemHitFlash = 0;
      teleportCooldown = 0;
      teleportFxTime = 0;
    }

    function enterShop() {
      screen = 'shop';
      setMode('classic');
      setupHubWorld();
      rebuildShopStands();
      menuZones.length = 0;
      const h = canvas.height;
      const baseY = h - 40;
      menuZones.push({ id: 'back', label: 'BACK', x: 60, y: baseY - 92, w: 130, h: 72 });
      player.x = 140;
      player.y = baseY - player.h - 2;
      player.vx = 0;
      player.vy = 0;
      jumpsLeft = 1;
      hasDoubleJump = false;
      doubleJumpTimer = 0;
      coyoteTimer = 0;
      jumpBufferTimer = 0;
      gameOver = false;
      deathTimer = 0;
      deathPieces = [];
      interactLatch = 0;
      shopMessage = 'Touch a stand to buy/select';
      shopMessageTime = 2.2;
      golemLives = 4;
      golemInvuln = 0;
      golemHitFlash = 0;
      teleportCooldown = 0;
      teleportFxTime = 0;
    }

    function startGame(mode) {
      screen = 'play';
      setMode(mode);
      hardReset();
    }

    function updateHub(dt) {
      const skin = getSkin(selectedSkinId);
      const isNinja = skin.id === 'ninja';
      const isMonks = skin.id === 'monks';
      const isGolem = skin.id === 'iron-golem';

      let accel = moveAccel;
      let maxSp = maxSpeedX;
      let jSp = jumpSpeed;
      if (isNinja) { accel *= 1.3; maxSp *= 1.35; jSp *= 1.25; }
      if (isGolem) { accel *= 0.85; maxSp *= 0.75; jSp *= 0.95; }

      if (teleportCooldown > 0) teleportCooldown = Math.max(0, teleportCooldown - dt);
      if (teleportFxTime > 0) teleportFxTime = Math.max(0, teleportFxTime - dt);
      if (golemInvuln > 0) golemInvuln = Math.max(0, golemInvuln - dt);
      if (golemHitFlash > 0) golemHitFlash = Math.max(0, golemHitFlash - dt);
      if (shopMessageTime > 0) shopMessageTime = Math.max(0, shopMessageTime - dt);

      const left = keys.has('a') || keys.has('arrowleft');
      const right = keys.has('d') || keys.has('arrowright');
      const jumpPressed = keys.has(' ') || keys.has('arrowup') || keys.has('w');
      const jumpEdge = jumpPressed && !jumpHeld;
      jumpHeld = jumpPressed;
      if (jumpEdge) jumpBufferTimer = jumpBufferTime;

      const teleportPressed = keys.has('e');
      const teleportEdge = teleportPressed && !teleportHeld;
      teleportHeld = teleportPressed;

      if (left && !right) {
        player.vx -= accel * dt;
        facing = -1;
      } else if (right && !left) {
        player.vx += accel * dt;
        facing = 1;
      } else {
        if (player.onGround) {
          if (Math.abs(player.vx) < frictionGround * dt) player.vx = 0;
          else player.vx -= Math.sign(player.vx) * frictionGround * dt;
        }
      }
      player.vx = Math.max(-maxSp, Math.min(maxSp, player.vx));

      if (jumpBufferTimer > 0) {
        jumpBufferTimer -= dt;
        if (jumpBufferTimer < 0) jumpBufferTimer = 0;
      }

      player.vy += gravity * dt;
      const wasOnGround = player.onGround;
      resolveCollisions(player, dt);
      if (player.onGround) {
        coyoteTimer = coyoteTime;
      } else {
        coyoteTimer -= dt;
        if (coyoteTimer < 0) coyoteTimer = 0;
      }

      if (jumpBufferTimer > 0 && jumpsLeft > 0) {
        const canGroundJump = player.onGround || coyoteTimer > 0;
        const canExtraJump = isMonks ? !player.onGround : false;
        if (canGroundJump || canExtraJump) {
          player.vy = -jSp;
          player.onGround = false;
          if (!isMonks) jumpsLeft -= 1;
          jumpBufferTimer = 0;
          coyoteTimer = 0;
          spawnParticles('jump', player.x + player.w * 0.5, player.y + player.h, 12);
          if (!isMonks) {
            shakeTime = 0.07;
            shakeStrength = Math.max(shakeStrength, 1.5);
          }
        }
      }

      if (player.onGround && !wasOnGround) {
        jumpsLeft = isMonks ? 999 : 1;
        spawnParticles('land', player.x + player.w * 0.5, player.y + player.h, 14);
        if (!isMonks) {
          shakeTime = 0.10;
          shakeStrength = Math.max(shakeStrength, 3.5);
        }
      }

      if (isNinja && teleportEdge && teleportCooldown <= 0) {
        teleportFrom.x = player.x;
        teleportFrom.y = player.y;
        const dist = 480;
        player.x += facing * dist;
        player.vx = 0;
        for (const s of platforms) {
          if (!rectsOverlap(player, s)) continue;
          if (facing > 0) player.x = s.x - player.w - 1;
          else player.x = s.x + s.w + 1;
        }
        teleportTo.x = player.x;
        teleportTo.y = player.y;
        teleportCooldown = 20;
        teleportFxTime = teleportFxDuration;
        spawnParticles('power', player.x + player.w * 0.5, player.y + player.h * 0.5, 18);
        shakeTime = 0.10;
        shakeStrength = Math.max(shakeStrength, 4);
      }

      if (interactLatch > 0) interactLatch = Math.max(0, interactLatch - dt);
      if (interactLatch <= 0) {
        for (const z of menuZones) {
          if (rectsOverlap(player, z)) {
            interactLatch = 0.35;
            if (screen === 'menu') {
              if (z.id === 'playClassic') startGame('classic');
              else if (z.id === 'playNoCP') startGame('nocp');
              else if (z.id === 'shop') enterShop();
            } else if (screen === 'shop') {
              if (z.id === 'back') enterMenu();
            }
            return;
          }
        }
        if (screen === 'shop') {
          for (const st of shopStands) {
            if (!rectsOverlap(player, st)) continue;
            interactLatch = 0.35;
            const skinItem = getSkin(st.skinId);
            if (!isSkinUnlocked(skinItem.id)) {
              if (coins >= skinItem.price) {
                coins -= skinItem.price;
                saveCoins();
                unlockedSkins.add(skinItem.id);
                selectedSkinId = skinItem.id;
                saveSkins();
                shopMessage = `Bought ${skinItem.name}!`;
                shopMessageTime = 1.7;
              } else {
                shopMessage = `Need ${skinItem.price - coins} more coins`;
                shopMessageTime = 1.7;
              }
            } else {
              selectedSkinId = skinItem.id;
              saveSkins();
              shopMessage = `Selected ${skinItem.name}`;
              shopMessageTime = 1.2;
            }
            return;
          }
        }
      }

      camera.x = Math.max(0, player.x - canvas.width * 0.45);
      camera.y = 0;
    }

    function update(dt) {
      t += dt;
      if (gameOver) {
        updateDeath(dt);
        updateParticles(dt);
        return;
      }
      if (screen !== 'play') {
        updateHub(dt);
        updateParticles(dt);
        return;
      }
      // Input: left/right
      const left = keys.has('a') || keys.has('arrowleft');
      const right = keys.has('d') || keys.has('arrowright');
      const jumpPressed = keys.has(' ') || keys.has('arrowup') || keys.has('w');
      const jumpEdge = jumpPressed && !jumpHeld; // only on press, not hold
      jumpHeld = jumpPressed;
      if (jumpEdge) {
        jumpBufferTimer = jumpBufferTime;
      }

      const skin = getSkin(selectedSkinId);
      const isNinja = skin.id === 'ninja';
      const isMonks = skin.id === 'monks';
      const isGolem = skin.id === 'iron-golem';

      if (teleportCooldown > 0) teleportCooldown = Math.max(0, teleportCooldown - dt);
      if (teleportFxTime > 0) teleportFxTime = Math.max(0, teleportFxTime - dt);
      if (golemInvuln > 0) golemInvuln = Math.max(0, golemInvuln - dt);
      if (golemHitFlash > 0) golemHitFlash = Math.max(0, golemHitFlash - dt);

      if (isMonks) {
        hasDoubleJump = true;
        doubleJumpTimer = 999999;
        if (player.onGround) jumpsLeft = 999;
        else jumpsLeft = Math.max(jumpsLeft, 2);
      }

      const teleportPressed = keys.has('e');
      const teleportEdge = teleportPressed && !teleportHeld;
      teleportHeld = teleportPressed;

      let accel = moveAccel;
      let maxSp = maxSpeedX;
      let jSp = jumpSpeed;
      if (isNinja) { accel *= 1.3; maxSp *= 1.35; jSp *= 1.25; }
      if (isGolem) { accel *= 0.85; maxSp *= 0.75; jSp *= 0.95; }

      // Horizontal accel
      if (left && !right) {
        player.vx -= accel * dt;
        facing = -1;
      } else if (right && !left) {
        player.vx += accel * dt;
        facing = 1;
      } else {
        // apply ground friction when no input
        if (player.onGround) {
          if (Math.abs(player.vx) < frictionGround * dt) player.vx = 0;
          else player.vx -= Math.sign(player.vx) * frictionGround * dt;
        }
      }
      // Clamp speed
      player.vx = Math.max(-maxSp, Math.min(maxSp, player.vx));

      // Timers
      if (doubleJumpTimer > 0) {
        doubleJumpTimer -= dt;
        if (doubleJumpTimer <= 0) { doubleJumpTimer = 0; hasDoubleJump = false; if (jumpsLeft > 1) jumpsLeft = 1; }
      }

      if (jumpBufferTimer > 0) {
        jumpBufferTimer -= dt;
        if (jumpBufferTimer < 0) jumpBufferTimer = 0;
      }

      // Gravity
      player.vy += gravity * dt;

      // Integrate and collide
      const wasOnGround = player.onGround;
      resolveCollisions(player, dt);

      if (player.onGround) {
        coyoteTimer = coyoteTime;
      } else {
        coyoteTimer -= dt;
        if (coyoteTimer < 0) coyoteTimer = 0;
      }

      if (jumpBufferTimer > 0 && jumpsLeft > 0) {
        const canGroundJump = player.onGround || coyoteTimer > 0;
        const canDoubleJump = isMonks ? (!player.onGround) : (hasDoubleJump && !player.onGround && coyoteTimer <= 0 && jumpsLeft === 1);
        if (canGroundJump || canDoubleJump) {
          player.vy = -jSp;
          player.onGround = false;
          if (!isMonks) jumpsLeft -= 1;
          jumpBufferTimer = 0;
          coyoteTimer = 0;
          spawnParticles('jump', player.x + player.w * 0.5, player.y + player.h, 14);
          if (!isMonks) {
            shakeTime = 0.07;
            shakeStrength = Math.max(shakeStrength, 1.5);
          }
        }
      }

      if (player.onGround && !wasOnGround) {
        jumpsLeft = isMonks ? 999 : (hasDoubleJump ? 2 : 1);
        spawnParticles('land', player.x + player.w * 0.5, player.y + player.h, 18);
        if (!isMonks) {
          shakeTime = 0.10;
          shakeStrength = Math.max(shakeStrength, 3.5);
        }
      }

      if (isNinja && teleportEdge && teleportCooldown <= 0) {
        teleportFrom.x = player.x;
        teleportFrom.y = player.y;
        const dist = 480;
        player.x += facing * dist;
        player.vx = 0;
        for (const s of platforms) {
          if (!rectsOverlap(player, s)) continue;
          if (facing > 0) player.x = s.x - player.w - 1;
          else player.x = s.x + s.w + 1;
        }
        teleportTo.x = player.x;
        teleportTo.y = player.y;
        teleportCooldown = 20;
        teleportFxTime = teleportFxDuration;
        spawnParticles('power', player.x + player.w * 0.5, player.y + player.h * 0.5, 22);
        shakeTime = 0.12;
        shakeStrength = Math.max(shakeStrength, 5);
      }

      // Hazards
      for (const hz of hazards) {
        if (rectsOverlap(player, hz)) {
          if (isGolem && golemInvuln <= 0) {
            if (golemLives > 0) {
              golemLives -= 1;
              golemInvuln = 0.6;
              golemHitFlash = 0.25;
              spawnParticles('land', player.x + player.w * 0.5, player.y + player.h * 0.5, 26);
              shakeTime = 0.12;
              shakeStrength = Math.max(shakeStrength, 5);
            } else {
              spawnParticles('power', player.x + player.w * 0.5, player.y + player.h * 0.5, 42);
              shakeTime = 0.22;
              shakeStrength = Math.max(shakeStrength, 8);
              triggerDeath();
            }
          } else if (!isGolem) {
            triggerDeath();
          }
        }
      }
      // Powerups
      for (let i = powerups.length - 1; i >= 0; i--) {
        const pu = powerups[i];
        if (rectsOverlap(player, pu)) {
          if (pu.type === 'double') {
            hasDoubleJump = true;
            doubleJumpTimer = 20; // seconds
            jumpsLeft = player.onGround ? 2 : Math.max(1, jumpsLeft);
            spawnParticles('power', pu.x + pu.w * 0.5, pu.y + pu.h * 0.5, 30);
            shakeTime = 0.12;
            shakeStrength = Math.max(shakeStrength, 4);
          }
          powerups.splice(i, 1);
        }
      }
      // Bounds fall
      if (player.y > canvas.height + 200) { triggerDeath(); }

      // Update max distance and checkpoints
      if (player.x > maxReachedX) maxReachedX = player.x;
      const distNow = Math.floor(maxReachedX);
      if (!noCheckpointsMode) {
        for (const cp of checkpoints) {
          if (rectsOverlap(player, cp)) {
            // Place checkpoint spawn on top of nearest platform below this cp
            let spawnY = canvas.height - 40 - player.h;
            for (const s of platforms) {
              if (s.x <= cp.x && cp.x <= s.x + s.w) {
                spawnY = Math.min(spawnY, s.y - player.h);
              }
            }
            lastCheckpoint.x = cp.x;
            lastCheckpoint.y = spawnY;
            checkpointFlashTime = 1.2;
          }
        }
      }

      const movingForward = player.vx > 20;
      if (movingForward) {
        nonstopForwardTime += dt;
      } else {
        nonstopForwardTime = 0;
        scoreTick = 0;
        comboActive = false;
      }
      if (nonstopForwardTime > 3) {
        if (!comboActive) {
          comboActive = true;
          comboAnimTime = comboAnimDuration;
        }
        scoreTick += dt;
        while (scoreTick >= 1) {
          score += 10;
          addCoins(1);
          scoreTick -= 1;
        }
      }

      if (noCheckpointsMode) {
        if (!bestDistanceBeaten && distNow > bestDistanceStart && distNow >= 1) {
          bestDistanceBeaten = true;
          bestDistAnimTime = bestDistAnimDuration;
          bestDistance = Math.max(bestDistance, distNow);
          try {
            localStorage.setItem(BEST_DISTANCE_KEY, String(bestDistance));
          } catch (e) {}
        }
        if (bestDistanceBeaten && distNow > bestDistance) {
          bestDistance = distNow;
          try {
            localStorage.setItem(BEST_DISTANCE_KEY, String(bestDistance));
          } catch (e) {}
        }
      }

      comboAnimTime = Math.max(0, comboAnimTime - dt);
      bestDistAnimTime = Math.max(0, bestDistAnimTime - dt);

      // Generate world ahead and move camera
      ensureWorldAhead();
      // Camera follows player
      camera.x = player.x - canvas.width * 0.4;
      camera.y = Math.max(0, player.y - canvas.height * 0.5);
      if (camera.x < 0) camera.x = 0;

      updateParticles(dt);

      trail.push({ x: player.x, y: player.y, t });
      while (trail.length > 14) trail.shift();
    }

    function draw() {
      // Clear to sky gradient (already via CSS background). Draw world elements.
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      if (shakeTime > 0) {
        const dtShake = Math.min(shakeTime, 1/60);
        shakeTime -= dtShake;
        if (shakeTime <= 0) { shakeTime = 0; shakeStrength = 0; }
      }
      const sx = shakeStrength ? (Math.sin(t * 60) * shakeStrength) : 0;
      const sy = shakeStrength ? (Math.cos(t * 73) * shakeStrength) : 0;

      ctx.save();
      ctx.translate(sx, sy);

      // Helper to draw rect in world coords
      function drawRect(x, y, w, h, fill, stroke) {
        ctx.fillStyle = fill;
        ctx.fillRect(worldToScreenX(x), worldToScreenY(y), w, h);
        if (stroke) {
          ctx.strokeStyle = stroke;
          ctx.strokeRect(worldToScreenX(x), worldToScreenY(y), w, h);
        }
      }

      function drawPanel(x, y, w, h) {
        ctx.save();
        ctx.globalAlpha = 0.85;
        roundRectPath(x, y, w, h, 12);
        ctx.fillStyle = 'rgba(255,255,255,0.72)';
        ctx.fill();
        ctx.globalAlpha = 0.35;
        ctx.lineWidth = 1;
        ctx.strokeStyle = 'rgba(0,0,0,0.35)';
        ctx.stroke();
        ctx.restore();
      }

      function drawParallax() {
        const w = canvas.width;
        const h = canvas.height;
        const ox = -(camera.x * 0.18) % 120;
        const oy = -(camera.y * 0.18) % 72;
        ctx.save();
        ctx.globalAlpha = 0.22;
        ctx.fillStyle = 'rgba(255,255,255,0.03)';
        ctx.strokeStyle = 'rgba(0,0,0,0.55)';
        ctx.lineWidth = 1;
        const brickW = 120;
        const brickH = 72;
        for (let y = -brickH; y < h + brickH; y += brickH) {
          const row = Math.floor((y + oy) / brickH);
          const rowShift = (row % 2) * (brickW / 2);
          for (let x = -brickW; x < w + brickW; x += brickW) {
            const bx = Math.floor(x + ox + rowShift);
            const by = Math.floor(y + oy);
            ctx.fillRect(bx + 1, by + 1, brickW - 2, brickH - 2);
            ctx.strokeRect(bx + 0.5, by + 0.5, brickW, brickH);
          }
        }
        ctx.globalAlpha = 0.65;
        const glow = ctx.createRadialGradient(w * 0.18, h * 0.92, 20, w * 0.18, h * 0.92, h * 0.75);
        glow.addColorStop(0, 'rgba(255,120,0,0.25)');
        glow.addColorStop(0.4, 'rgba(255,40,0,0.14)');
        glow.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = glow;
        ctx.fillRect(0, 0, w, h);
        ctx.restore();
      }

      function drawVignette() {
        const w = canvas.width;
        const h = canvas.height;
        ctx.save();
        const g = ctx.createRadialGradient(w * 0.5, h * 0.5, Math.min(w, h) * 0.2, w * 0.5, h * 0.5, Math.max(w, h) * 0.75);
        g.addColorStop(0, 'rgba(0,0,0,0)');
        g.addColorStop(1, 'rgba(0,0,0,0.42)');
        ctx.fillStyle = g;
        ctx.fillRect(0, 0, w, h);
        ctx.restore();
      }

      function drawPlatform(s) {
        const x = worldToScreenX(s.x);
        const y = worldToScreenY(s.y);
        const base = s.type === 'ground' ? '#4b5563' : '#6b7280';
        const top = s.type === 'ground' ? '#9ca3af' : '#d1d5db';
        const bottom = s.type === 'ground' ? '#111827' : '#1f2937';
        ctx.save();
        ctx.shadowColor = 'rgba(0,0,0,0.35)';
        ctx.shadowBlur = 12;
        ctx.shadowOffsetY = 6;
        roundRectPath(x, y, s.w, s.h, 6);
        const g = ctx.createLinearGradient(0, y, 0, y + s.h);
        g.addColorStop(0, top);
        g.addColorStop(0.38, base);
        g.addColorStop(1, bottom);
        ctx.fillStyle = g;
        ctx.fill();
        ctx.shadowBlur = 0;
        ctx.globalAlpha = 0.35;
        ctx.strokeStyle = 'rgba(255,255,255,0.25)';
        ctx.lineWidth = 1;
        ctx.stroke();
        ctx.restore();
      }

      function drawHazard(hz) {
        const x = worldToScreenX(hz.x);
        const y = worldToScreenY(hz.y);
        const spikes = Math.max(3, Math.floor(hz.w / 14));
        const step = hz.w / spikes;
        ctx.save();
        ctx.shadowColor = 'rgba(239,68,68,0.55)';
        ctx.shadowBlur = 14;
        const g = ctx.createLinearGradient(0, y, 0, y + hz.h);
        g.addColorStop(0, '#fecaca');
        g.addColorStop(0.35, '#ef4444');
        g.addColorStop(1, '#7f1d1d');
        ctx.fillStyle = g;
        ctx.beginPath();
        ctx.moveTo(x, y + hz.h);
        for (let i = 0; i < spikes; i++) {
          const x0 = x + i * step;
          const x1 = x0 + step;
          const xm = (x0 + x1) / 2;
          ctx.lineTo(x0, y + hz.h);
          ctx.lineTo(xm, y);
          ctx.lineTo(x1, y + hz.h);
        }
        ctx.closePath();
        ctx.fill();
        ctx.shadowBlur = 0;
        ctx.globalAlpha = 0.35;
        ctx.strokeStyle = 'rgba(0,0,0,0.35)';
        ctx.lineWidth = 1;
        ctx.stroke();
        ctx.restore();
      }

      function drawPowerup(pu) {
        const cx = pu.x - camera.x, cy = pu.y - camera.y;
        const pulse = 0.5 + 0.5 * Math.sin(t * 5);
        ctx.save();
        ctx.translate(Math.floor(cx + pu.w/2), Math.floor(cy + pu.h/2));
        ctx.rotate(Math.PI/4);
        ctx.shadowColor = 'rgba(6,182,212,0.75)';
        ctx.shadowBlur = 16;
        ctx.fillStyle = `rgba(6,182,212,${lerp(0.65, 0.95, pulse)})`;
        ctx.fillRect(-pu.w/2, -pu.h/2, pu.w, pu.h);
        ctx.shadowBlur = 0;
        ctx.globalAlpha = 0.35;
        ctx.strokeStyle = 'rgba(255,255,255,0.5)';
        ctx.lineWidth = 1;
        ctx.strokeRect(-pu.w/2, -pu.h/2, pu.w, pu.h);
        ctx.restore();
      }

      function drawCheckpoint(cp) {
        const x = worldToScreenX(cp.x);
        const y = worldToScreenY(cp.y);
        ctx.save();
        const pulse = 0.45 + 0.55 * Math.sin(t * 3.3);
        ctx.shadowColor = 'rgba(34,197,94,0.55)';
        ctx.shadowBlur = 14;
        const g = ctx.createLinearGradient(0, y, 0, y + cp.h);
        g.addColorStop(0, `rgba(34,197,94,${lerp(0.55, 0.95, pulse)})`);
        g.addColorStop(1, 'rgba(21,128,61,0.95)');
        roundRectPath(x, y, cp.w, cp.h, 6);
        ctx.fillStyle = g;
        ctx.fill();
        ctx.shadowBlur = 0;
        ctx.globalAlpha = 0.3;
        ctx.strokeStyle = 'rgba(255,255,255,0.5)';
        ctx.lineWidth = 1;
        ctx.stroke();
        ctx.restore();
      }

      function drawPlayer() {
        if (gameOver && deathPieces.length) {
          const a = clamp(1 - (deathTimer / deathDuration), 0, 1);
          for (const p of deathPieces) {
            const x = worldToScreenX(p.x);
            const y = worldToScreenY(p.y);
            ctx.save();
            ctx.translate(Math.floor(x + p.w * 0.5), Math.floor(y + p.h * 0.5));
            ctx.rotate(p.rot);
            ctx.globalAlpha = a;
            ctx.fillStyle = '#111';
            ctx.shadowColor = 'rgba(0,0,0,0.55)';
            ctx.shadowBlur = 10;
            ctx.fillRect(-p.w * 0.5, -p.h * 0.5, p.w, p.h);
            ctx.shadowBlur = 0;
            ctx.globalAlpha = a * 0.25;
            ctx.strokeStyle = 'rgba(255,255,255,0.14)';
            ctx.lineWidth = 1;
            ctx.strokeRect(-p.w * 0.5, -p.h * 0.5, p.w, p.h);
            ctx.restore();
          }
          return;
        }

        const skin = getSkin(selectedSkinId);
        const isNinja = skin.id === 'ninja';
        const isMonks = skin.id === 'monks';
        const isGolem = skin.id === 'iron-golem';
        const body = skin.body || '#111';
        const accent = skin.accent || '#3b82f6';

        if (isNinja && teleportFxTime > 0) {
          const elapsed = teleportFxDuration - teleportFxTime;
          const half = teleportFxDuration * 0.5;
          const from = { x: teleportFrom.x + player.w * 0.5, y: teleportFrom.y + player.h * 0.5 };
          const to = { x: teleportTo.x + player.w * 0.5, y: teleportTo.y + player.h * 0.5 };
          const at = elapsed < half ? from : to;
          const p = elapsed < half ? (elapsed / half) : ((elapsed - half) / half);
          const r = elapsed < half ? lerp(10, 2, p) : lerp(2, 11, p);
          const x = worldToScreenX(at.x);
          const y = worldToScreenY(at.y);
          ctx.save();
          const fxA = elapsed < half ? lerp(1, 0.1, p) : lerp(0.1, 1, p);
          const fxFromX = worldToScreenX(from.x);
          const fxFromY = worldToScreenY(from.y);
          const fxToX = worldToScreenX(to.x);
          const fxToY = worldToScreenY(to.y);
          ctx.globalAlpha = fxA * 0.7;
          ctx.strokeStyle = 'rgba(239,68,68,0.55)';
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.moveTo(fxFromX, fxFromY);
          ctx.lineTo(fxToX, fxToY);
          ctx.stroke();
          ctx.globalAlpha = elapsed < half ? lerp(1, 0.1, p) : lerp(0.1, 1, p);
          ctx.fillStyle = body;
          ctx.shadowColor = 'rgba(239,68,68,0.55)';
          ctx.shadowBlur = 18;
          ctx.beginPath();
          ctx.arc(x, y, r, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
          return;
        }

        for (let i = 0; i < trail.length; i++) {
          const p = trail[i];
          const a = i / trail.length;
          const x = worldToScreenX(p.x);
          const y = worldToScreenY(p.y);
          ctx.save();
          ctx.globalAlpha = a * 0.18;
          roundRectPath(x, y, player.w, player.h, 10);
          ctx.fillStyle = rgba(body, 1);
          ctx.fill();
          ctx.restore();
        }

        const x = worldToScreenX(player.x);
        const y = worldToScreenY(player.y);
        ctx.save();
        ctx.shadowColor = 'rgba(0,0,0,0.55)';
        ctx.shadowBlur = 14;
        ctx.shadowOffsetY = 6;
        roundRectPath(x, y, player.w, player.h, 10);
        const g = ctx.createLinearGradient(0, y, 0, y + player.h);
        g.addColorStop(0, rgba(body, 1));
        g.addColorStop(1, rgba(body, 0.55));
        ctx.fillStyle = g;
        ctx.fill();
        ctx.shadowBlur = 0;
        ctx.globalAlpha = 0.35;
        ctx.strokeStyle = 'rgba(255,255,255,0.12)';
        ctx.lineWidth = 1;
        ctx.stroke();
        ctx.globalAlpha = 0.9;
        if (isNinja) {
          ctx.fillStyle = 'rgba(0,0,0,0.75)';
          roundRectPath(x + 8, y + 14, player.w - 16, 8, 4);
          ctx.fill();
          ctx.fillStyle = 'rgba(239,68,68,0.95)';
          ctx.beginPath();
          ctx.arc(x + 14, y + 22, 3, 0, Math.PI * 2);
          ctx.arc(x + player.w - 14, y + 22, 3, 0, Math.PI * 2);
          ctx.fill();
        } else if (isMonks) {
          roundRectPath(x + 8, y + 12, player.w - 16, 10, 6);
          const vg = ctx.createLinearGradient(x, 0, x + player.w, 0);
          vg.addColorStop(0, rgba(accent, 0.85));
          vg.addColorStop(1, 'rgba(255,255,255,0.65)');
          ctx.fillStyle = vg;
          ctx.fill();
        } else {
          const visorH = 10;
          roundRectPath(x + 8, y + 12, player.w - 16, visorH, 6);
          const vg = ctx.createLinearGradient(x, 0, x + player.w, 0);
          vg.addColorStop(0, rgba(accent, 0.8));
          vg.addColorStop(1, rgba(accent, 0.45));
          ctx.fillStyle = vg;
          ctx.fill();
        }

        if (isGolem) {
          const cracks = clamp(4 - golemLives, 0, 4);
          if (cracks > 0) {
            ctx.save();
            ctx.globalAlpha = lerp(0.25, 0.7, cracks / 4) + (golemHitFlash > 0 ? 0.25 : 0);
            ctx.strokeStyle = 'rgba(0,0,0,0.6)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(x + 6, y + 10);
            ctx.lineTo(x + player.w - 8, y + 18);
            if (cracks >= 2) {
              ctx.moveTo(x + 10, y + player.h - 10);
              ctx.lineTo(x + player.w - 12, y + 26);
            }
            if (cracks >= 3) {
              ctx.moveTo(x + player.w * 0.5, y + 8);
              ctx.lineTo(x + player.w * 0.35, y + player.h - 6);
            }
            if (cracks >= 4) {
              ctx.moveTo(x + player.w * 0.7, y + 10);
              ctx.lineTo(x + player.w * 0.55, y + player.h - 6);
            }
            ctx.stroke();
            ctx.restore();
          }
        }
        ctx.restore();
      }

      function drawParticles() {
        for (const p of particles) {
          const a = clamp(p.life / p.ttl, 0, 1);
          const x = worldToScreenX(p.x);
          const y = worldToScreenY(p.y);
          ctx.save();
          ctx.globalAlpha = a;
          ctx.fillStyle = rgba(p.color, 0.95);
          ctx.shadowColor = rgba(p.color, 0.65);
          ctx.shadowBlur = 10;
          ctx.beginPath();
          ctx.arc(x, y, p.size * lerp(0.6, 1.0, a), 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
        }
      }

      drawParallax();

      // Draw platforms
      for (const s of platforms) {
        drawPlatform(s);
      }
      // Draw hazards (spikes as red bars)
      for (const hz of hazards) {
        drawHazard(hz);
      }
      // Draw powerups (double-jump = cyan diamond)
      for (const pu of powerups) {
        drawPowerup(pu);
      }
      // Draw checkpoints
      for (const cp of checkpoints) {
        drawCheckpoint(cp);
      }

      // Draw player
      drawPlayer();

      drawParticles();

      const skin = getSkin(selectedSkinId);

      if (screen === 'menu' || screen === 'shop') {
        for (const z of menuZones) {
          const zx = worldToScreenX(z.x);
          const zy = worldToScreenY(z.y);
          const over = rectsOverlap(player, z);
          ctx.save();
          ctx.globalAlpha = over ? 0.95 : 0.78;
          roundRectPath(zx, zy, z.w, z.h, 14);
          ctx.fillStyle = over ? 'rgba(255,255,255,0.82)' : 'rgba(255,255,255,0.65)';
          ctx.fill();
          ctx.globalAlpha = 0.35;
          ctx.lineWidth = 1;
          ctx.strokeStyle = 'rgba(0,0,0,0.35)';
          ctx.stroke();
          ctx.globalAlpha = 1;
          ctx.fillStyle = '#111';
          ctx.textAlign = 'center';
          ctx.font = 'bold 16px sans-serif';
          const parts = String(z.label).split('\n');
          for (let i = 0; i < parts.length; i++) {
            ctx.fillText(parts[i], zx + z.w * 0.5, zy + 28 + i * 18);
          }
          ctx.restore();
        }

        if (screen === 'shop') {
          for (const st of shopStands) {
            const s = getSkin(st.skinId);
            const unlocked = isSkinUnlocked(s.id);
            const over = rectsOverlap(player, st);
            const sx = worldToScreenX(st.x);
            const sy = worldToScreenY(st.y);
            ctx.save();
            ctx.globalAlpha = over ? 0.95 : 0.8;
            roundRectPath(sx, sy, st.w, st.h, 12);
            ctx.fillStyle = unlocked ? 'rgba(255,255,255,0.28)' : 'rgba(0,0,0,0.25)';
            ctx.fill();
            ctx.globalAlpha = 0.45;
            ctx.strokeStyle = unlocked ? 'rgba(255,255,255,0.35)' : 'rgba(255,255,255,0.18)';
            ctx.lineWidth = 1;
            ctx.stroke();
            ctx.globalAlpha = 1;
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 14px sans-serif';
            ctx.textAlign = 'left';
            ctx.fillText(s.name, sx + 12, sy + 22);
            ctx.textAlign = 'right';
            ctx.fillStyle = unlocked ? 'rgba(34,197,94,0.95)' : 'rgba(251,191,36,0.95)';
            ctx.fillText(unlocked ? 'OWNED' : `${s.price}`, sx + st.w - 12, sy + 22);
            ctx.textAlign = 'left';
            ctx.fillStyle = s.body;
            roundRectPath(sx + 12, sy + 32, 24, 30, 6);
            ctx.fill();
            ctx.fillStyle = s.accent;
            roundRectPath(sx + 18, sy + 42, 12, 8, 4);
            ctx.fill();
            if (selectedSkinId === s.id) {
              ctx.globalAlpha = 0.85;
              ctx.fillStyle = 'rgba(59,130,246,0.9)';
              roundRectPath(sx + st.w - 52, sy + st.h - 24, 40, 16, 6);
              ctx.fill();
              ctx.globalAlpha = 1;
              ctx.fillStyle = '#fff';
              ctx.font = 'bold 11px sans-serif';
              ctx.textAlign = 'center';
              ctx.fillText('ON', sx + st.w - 32, sy + st.h - 12);
            }
            ctx.restore();
          }
        }
      }

      // UI overlays
      const lines = [];
      lines.push(`Coins: ${coins}`);
      lines.push(`Skin: ${skin.name}`);
      if (screen === 'play') {
        lines.push(`Mode: ${modeLabel}`);
        if (!noCheckpointsMode) {
          lines.push('Touch green posts to set checkpoint');
          lines.push('R respawn | Shift+R restart');
        } else {
          lines.push('No checkpoints - one run');
          lines.push('R restart');
        }
        lines.push(`Distance: ${Math.floor(maxReachedX)} px`);
        lines.push(`Score: ${score}`);
        if (nonstopForwardTime >= 3) lines.push('Nonstop: +10/s');
        else lines.push(`Nonstop: ${nonstopForwardTime.toFixed(1)}/3.0s`);
        if (noCheckpointsMode) lines.push(`Best Score: ${bestScore} | Best Dist: ${bestDistance}px`);
        if (skin.id === 'ninja') lines.push(`Teleport (E): ${teleportCooldown > 0 ? teleportCooldown.toFixed(0) + 's' : 'READY'}`);
        if (skin.id === 'iron-golem') lines.push(`Shield: ${Math.max(0, golemLives)}/4`);
        if (hasDoubleJump && skin.id !== 'monks') lines.push(`Double-jump: ON (${Math.ceil(doubleJumpTimer)}s)`);
      } else if (screen === 'menu') {
        lines.push('Main Menu: move into a button');
      } else if (screen === 'shop') {
        lines.push('Shop: touch a stand');
        if (shopMessageTime > 0 && shopMessage) lines.push(shopMessage);
      }

      const panelW = 500;
      const lineH = 20;
      const panelH = 18 + lines.length * lineH;
      drawPanel(12, 12, panelW, panelH);
      ctx.font = '16px sans-serif';
      ctx.fillStyle = '#111';
      let yy = 36;
      for (const s of lines) {
        ctx.fillText(s, 26, yy);
        yy += lineH;
      }

      function drawPopText(text, timeLeft, duration, y, color) {
        const a = clamp(timeLeft / duration, 0, 1);
        const p = 1 - a;
        const ease = 1 - Math.pow(1 - p, 3);
        const scale = lerp(0.92, 1.14, ease);
        ctx.save();
        ctx.translate(canvas.width / 2, y);
        ctx.scale(scale, scale);
        ctx.globalAlpha = a;
        ctx.textAlign = 'center';
        ctx.font = 'bold 30px sans-serif';
        ctx.shadowColor = 'rgba(0,0,0,0.55)';
        ctx.shadowBlur = 16;
        ctx.fillStyle = color;
        ctx.fillText(text, 0, 0);
        ctx.restore();
      }

      if (!gameOver) {
        if (comboAnimTime > 0) drawPopText('NONSTOP COMBO!', comboAnimTime, comboAnimDuration, 128, '#f97316');
        if (bestDistAnimTime > 0) drawPopText('NEW BEST DISTANCE!', bestDistAnimTime, bestDistAnimDuration, 164, '#fbbf24');
      }

      // Checkpoint flash
      if (checkpointFlashTime > 0) {
        checkpointFlashTime -= Math.min(checkpointFlashTime, 1/60);
        ctx.save();
        ctx.globalAlpha = Math.min(1, checkpointFlashTime / 1.2 * 1.5);
        ctx.fillStyle = '#22c55e';
        ctx.textAlign = 'center';
        ctx.font = 'bold 26px sans-serif';
        ctx.fillText('Checkpoint saved!', canvas.width/2, 80);
        ctx.restore();
      }

      if (gameOver && deathTimer >= deathDuration) {
        if (!bestSaved && noCheckpointsMode) {
          const dist = Math.floor(maxReachedX);
          if (score > bestScore) bestScore = score;
          if (dist > bestDistance) bestDistance = dist;
          try {
            localStorage.setItem(BEST_SCORE_KEY, String(bestScore));
            localStorage.setItem(BEST_DISTANCE_KEY, String(bestDistance));
          } catch (e) {}
          bestSaved = true;
        }
        ctx.fillStyle = 'rgba(0,0,0,0.5)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#fff';
        ctx.textAlign = 'center';
        ctx.font = '28px sans-serif';
        ctx.fillText('You fell or hit spikes!', canvas.width/2, canvas.height/2 - 10);
        ctx.font = '20px sans-serif';
        ctx.fillText(noCheckpointsMode ? 'Press R to restart run' : 'Press R to respawn at last checkpoint', canvas.width/2, canvas.height/2 + 24);
        ctx.font = '18px sans-serif';
        ctx.fillText(`Distance: ${Math.floor(maxReachedX)} px   Score: ${score}`, canvas.width/2, canvas.height/2 + 52);
        if (noCheckpointsMode) {
          ctx.fillText(`Best Distance: ${bestDistance} px   Best Score: ${bestScore}`, canvas.width/2, canvas.height/2 + 76);
        }
        ctx.textAlign = 'left';
      }

      ctx.restore();

      drawVignette();
    }

    let last = performance.now();
    function loop(ts) {
      const dt = Math.min(1/30, (ts - last) / 1000);
      last = ts;

      const escapePressed = keys.has('escape');
      const escapeEdge = escapePressed && !escapeHeld;
      escapeHeld = escapePressed;
      if (escapeEdge) {
        if (screen === 'play') enterMenu();
      }
      if (keys.has('r')) {
        if (screen === 'play') {
          if (!gameOver || deathTimer >= deathDuration) {
            if (keys.has('shift')) {
              hardReset();
            } else {
              if (noCheckpointsMode) hardReset(); else respawnAtCheckpoint();
            }
          }
        }
      }
      update(dt);
      draw();
      requestAnimationFrame(loop);
    }
    if (screen === 'menu') enterMenu();
    else hardReset();
    requestAnimationFrame(loop);
  </script>
</body>
</html>