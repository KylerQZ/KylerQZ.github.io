<!DOCTYPE html>
<html>
<head>
  <title>Parkour</title>
  <style>
    body {
      background: #0a0a0a;
      margin: 0;
      padding: 0;
      overflow: hidden; /* 防止出现滚动条 */
      text-align: center;
    }
    canvas#game {
      display: block;
      width: 100vw;
      height: 100vh;
      background:
        radial-gradient(circle at 18% 82%, rgba(255, 140, 0, 0.35), rgba(0,0,0,0) 55%),
        radial-gradient(circle at 78% 28%, rgba(255, 60, 0, 0.25), rgba(0,0,0,0) 60%),
        linear-gradient(180deg, #1a0f0b 0%, #050203 100%),
        repeating-linear-gradient(0deg, rgba(0,0,0,0.45) 0 2px, rgba(0,0,0,0) 2px 64px),
        repeating-linear-gradient(90deg, rgba(0,0,0,0.42) 0 2px, rgba(0,0,0,0) 2px 140px);
      cursor: default;
    }
  </style>
</head>
<body>
  <canvas id="game"></canvas>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');

    let screen = 'play';
    const menuZones = [];
    const shopStands = [];
    let menuView = 'main';
    let shopOwnedSkinId = 'none';
    let shopPreviewSkinId = null;

    const SETTINGS_KEY = 'parkour_settings_v1';
    let sfxVolume = 1;
    let shakeEnabled = true;
    let particlesEnabled = true;
    let settingsOpen = false;

    let audioCtx = null;
    function ensureAudio() {
      try {
        if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        if (audioCtx.state === 'suspended') audioCtx.resume();
      } catch (e) {}
    }

    function saveSettings() {
      try {
        localStorage.setItem(SETTINGS_KEY, JSON.stringify({ v: 1, sfxVolume, shakeEnabled, particlesEnabled }));
      } catch (e) {}
    }

    function loadSettings() {
      let raw = null;
      try { raw = localStorage.getItem(SETTINGS_KEY); } catch (e) { raw = null; }
      if (!raw) return;
      let data = null;
      try { data = JSON.parse(raw); } catch (e) { data = null; }
      if (!data || data.v !== 1) return;
      if (typeof data.sfxVolume === 'number') sfxVolume = Math.max(0, Math.min(1, data.sfxVolume));
      if (typeof data.shakeEnabled === 'boolean') shakeEnabled = data.shakeEnabled;
      if (typeof data.particlesEnabled === 'boolean') particlesEnabled = data.particlesEnabled;
    }
    function playTone(f0, f1, dur, type, gain, detune = 0) {
      if (!audioCtx) return;
      const t = audioCtx.currentTime;
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      o.type = type || 'sine';
      o.frequency.setValueAtTime(f0, t);
      if (f1 != null) o.frequency.exponentialRampToValueAtTime(Math.max(20, f1), t + Math.max(0.01, dur));
      if (detune) o.detune.setValueAtTime(detune, t);
      const vol = Math.max(0, Math.min(1, sfxVolume || 0));
      const gg = (gain || 0.08) * vol;
      g.gain.setValueAtTime(0.0001, t);
      g.gain.exponentialRampToValueAtTime(Math.max(0.0002, gg), t + 0.01);
      g.gain.exponentialRampToValueAtTime(0.0001, t + Math.max(0.03, dur));
      o.connect(g);
      g.connect(audioCtx.destination);
      o.start(t);
      o.stop(t + Math.max(0.03, dur) + 0.02);
    }
    function playNoise(dur, gain) {
      if (!audioCtx) return;
      const t = audioCtx.currentTime;
      const sr = audioCtx.sampleRate;
      const len = Math.max(1, Math.floor(sr * dur));
      const buf = audioCtx.createBuffer(1, len, sr);
      const data = buf.getChannelData(0);
      for (let i = 0; i < len; i++) data[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / len, 2);
      const src = audioCtx.createBufferSource();
      src.buffer = buf;
      const g = audioCtx.createGain();
      const vol = Math.max(0, Math.min(1, sfxVolume || 0));
      const gg = (gain || 0.08) * vol;
      g.gain.setValueAtTime(Math.max(0.0002, gg), t);
      g.gain.exponentialRampToValueAtTime(0.0001, t + Math.max(0.03, dur));
      src.connect(g);
      g.connect(audioCtx.destination);
      src.start(t);
      src.stop(t + Math.max(0.03, dur) + 0.02);
    }

    function playWhoosh(dur, gain) {
      if (!audioCtx) return;
      const t = audioCtx.currentTime;
      const d = Math.max(0.05, dur || 0.22);
      const sr = audioCtx.sampleRate;
      const len = Math.max(1, Math.floor(sr * d));
      const buf = audioCtx.createBuffer(1, len, sr);
      const data = buf.getChannelData(0);
      for (let i = 0; i < len; i++) data[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / len, 0.7);
      const src = audioCtx.createBufferSource();
      src.buffer = buf;

      const hp = audioCtx.createBiquadFilter();
      hp.type = 'highpass';
      hp.frequency.setValueAtTime(140, t);

      const bp = audioCtx.createBiquadFilter();
      bp.type = 'bandpass';
      bp.Q.setValueAtTime(0.9, t);
      bp.frequency.setValueAtTime(2200, t);
      bp.frequency.exponentialRampToValueAtTime(260, t + d);

      const g = audioCtx.createGain();
      const vol = Math.max(0, Math.min(1, sfxVolume || 0));
      const gg = (gain || 0.09) * vol;
      g.gain.setValueAtTime(0.0001, t);
      g.gain.exponentialRampToValueAtTime(Math.max(0.0002, gg), t + 0.02);
      g.gain.exponentialRampToValueAtTime(0.0001, t + d);

      src.connect(hp);
      hp.connect(bp);
      bp.connect(g);
      g.connect(audioCtx.destination);
      src.start(t);
      src.stop(t + d + 0.02);
    }

    function sfxClick() { playTone(520, 380, 0.07, 'square', 0.04); }
    function sfxSelect() { playTone(520, 760, 0.09, 'triangle', 0.05); }
    function sfxBuy() { playTone(420, 980, 0.14, 'sine', 0.06); playTone(980, 1180, 0.10, 'sine', 0.03, 8); }
    function sfxDeny() { playTone(220, 160, 0.16, 'sawtooth', 0.05); }
    function sfxJump() { playWhoosh(0.09, 0.06); }
    function sfxLand() { playNoise(0.08, 0.05); playTone(120, 90, 0.10, 'sine', 0.03); }
    function sfxTeleport() { playWhoosh(0.22, 0.10); }
    function sfxShieldHit() { playTone(160, 70, 0.12, 'square', 0.06); playNoise(0.05, 0.03); }
    function sfxGolemCrash() { playNoise(0.14, 0.09); playTone(95, 55, 0.22, 'square', 0.08); playTone(55, 40, 0.25, 'sawtooth', 0.05, -6); }
    function sfxDeath() { playNoise(0.22, 0.07); playTone(220, 60, 0.30, 'sawtooth', 0.06); }
    function sfxCoin() { ensureAudio(); playTone(680, 980, 0.10, 'triangle', 0.05, 6); playTone(980, 1240, 0.08, 'sine', 0.03, 10); }
    function sfxBounce() { playTone(220, 520, 0.10, 'square', 0.05); playTone(520, 820, 0.08, 'triangle', 0.03, 6); }

    function resize() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      if (screen === 'menu') {
        rebuildShopStands();
        setMenuView(menuView);
      }
    }
    window.addEventListener('resize', resize);
    resize();
    loadSettings();

    // Input
    const keys = new Set();
    const isTouchDevice = (('ontouchstart' in window) || (navigator.maxTouchPoints || 0) > 0);
    const touchKeyOwners = new Map(); // key -> touch identifier
    let activeTouches = [];
    window.addEventListener('keydown', (e) => {
      ensureAudio();
      keys.add(e.key.toLowerCase());
      if ([' ', 'arrowup'].includes(e.key.toLowerCase())) e.preventDefault();
    });
    window.addEventListener('keyup', (e) => keys.delete(e.key.toLowerCase()));

    function getMobileButtons() {
      const pad = 18;
      const w = 86;
      const h = 56;
      const y = canvas.height - pad - h;
      const leftX = pad;
      const rightX = leftX + w + 12;
      const jumpX = canvas.width - pad - w;
      const teleX = jumpX - 12 - w;
      const superX = teleX - 12 - w;
      return {
        left: { id: 'left', key: 'a', label: 'LEFT', x: leftX, y, w, h },
        right: { id: 'right', key: 'd', label: 'RIGHT', x: rightX, y, w, h },
        super: { id: 'super', key: 'g', label: 'SUPER', x: superX, y, w, h },
        teleport: { id: 'teleport', key: 'e', label: 'TELE', x: teleX, y, w, h },
        jump: { id: 'jump', key: ' ', label: 'JUMP', x: jumpX, y, w, h },
      };
    }

    function keyForMobileButtonAt(sx, sy) {
      const b = getMobileButtons();
      const list = [b.left, b.right, b.jump, b.teleport, b.super];
      for (const it of list) {
        if (sx >= it.x && sx <= it.x + it.w && sy >= it.y && sy <= it.y + it.h) return it;
      }
      return null;
    }

    function syncTouchKeysFromTouches(touches) {
      activeTouches = Array.from(touches || []);
      // release any keys whose owner touch no longer exists
      for (const [k, id] of Array.from(touchKeyOwners.entries())) {
        if (!activeTouches.some(t => t.identifier === id)) {
          touchKeyOwners.delete(k);
          keys.delete(k);
        }
      }

      if (screen !== 'play' || evoTargeting || settingsOpen) return;
      if (!isTouchDevice) return;

      const r = canvas.getBoundingClientRect();
      for (const t of activeTouches) {
        const sx = (t.clientX - r.left) * (canvas.width / r.width);
        const sy = (t.clientY - r.top) * (canvas.height / r.height);
        const btn = keyForMobileButtonAt(sx, sy);
        if (!btn) continue;
        if (!touchKeyOwners.has(btn.key)) {
          touchKeyOwners.set(btn.key, t.identifier);
          keys.add(btn.key);
        }
      }
    }

    let pointerWorldX = 0;
    let pointerWorldY = 0;
    let pointerScreenX = 0;
    let pointerScreenY = 0;
    let pointerActive = false;

    function pointInRect(wx, wy, r) {
      return wx >= r.x && wx <= r.x + r.w && wy >= r.y && wy <= r.y + r.h;
    }

    function updatePointerWorld(clientX, clientY) {
      const r = canvas.getBoundingClientRect();
      const sx = (clientX - r.left) * (canvas.width / r.width);
      const sy = (clientY - r.top) * (canvas.height / r.height);
      pointerScreenX = sx;
      pointerScreenY = sy;
      pointerWorldX = sx + camera.x;
      pointerWorldY = sy + camera.y;
      pointerActive = true;
    }

    function activateShopSkinId(skinId) {
      const skinItem = getSkin(skinId);
      if (!isSkinUnlocked(skinItem.id)) {
        if (menuView === 'shop' && shopPreviewSkinId !== skinItem.id) {
          shopPreviewSkinId = skinItem.id;
          selectedSkinId = skinItem.id;
          shopMessage = `Previewing ${skinItem.name} - click again to buy`;
          shopMessageTime = 1.7;
          sfxSelect();
          if (menuView === 'shop') shopRespawn();
          return;
        }

        if (skinItem.reqBestDist && bestDistanceAll < skinItem.reqBestDist) {
          shopMessage = `Need Best Distance ${skinItem.reqBestDist}+`;
          shopMessageTime = 1.7;
          sfxDeny();
          return;
        }

        if (skinItem.reqSkin && !isSkinUnlocked(skinItem.reqSkin)) {
          const reqName = getSkin(skinItem.reqSkin).name;
          shopMessage = `Need ${reqName} first`;
          shopMessageTime = 1.7;
          sfxDeny();
          return;
        }

        if (coins >= skinItem.price) {
          coins -= skinItem.price;
          saveCoins();
          unlockedSkins.add(skinItem.id);
          selectedSkinId = skinItem.id;
          saveSkins();
          shopMessage = `Bought ${skinItem.name}!`;
          shopMessageTime = 1.7;
          sfxBuy();
          shopPreviewSkinId = null;
          if (menuView === 'shop') shopRespawn();
        } else {
          shopMessage = `Need ${skinItem.price - coins} more coins`;
          shopMessageTime = 1.7;
          sfxDeny();
        }
      } else {
        selectedSkinId = skinItem.id;
        saveSkins();
        shopMessage = `Selected ${skinItem.name}`;
        shopMessageTime = 1.2;
        sfxSelect();
        shopPreviewSkinId = null;
        if (menuView === 'shop') shopRespawn();
      }
    }

    function activateMenuZoneId(id) {
      if (screen === 'menu') {
        if (id === 'playClassic') { sfxClick(); startGame('classic'); }
        else if (id === 'playNoCP') { sfxClick(); startGame('nocp'); }
        else if (id === 'playDaily') { sfxClick(); startGame('daily'); }
        else if (id === 'playWeekly') { sfxClick(); startGame('weekly'); }
        else if (id === 'openSkinsShop') {
          sfxClick();
          shopOwnedSkinId = selectedSkinId;
          shopPreviewSkinId = null;
          setupShopWorld();
          rebuildShopStands();
          setMenuView('shop');
          const h = canvas.height;
          const baseY = h - 40;
          player.x = 140;
          player.y = baseY - player.h - 2;
          player.vx = 0;
          player.vy = 0;
          jumpsLeft = 1;
          hasDoubleJump = false;
          doubleJumpTimer = 0;
          coyoteTimer = 0;
          jumpBufferTimer = 0;
          camera.x = 0;
          shopMessage = '';
          shopMessageTime = 0;
          shopRespawn();
        }
        else if (id === 'backToMain') {
          sfxClick();
          if (!isSkinUnlocked(selectedSkinId)) {
            selectedSkinId = shopOwnedSkinId || 'none';
            saveSkins();
          }
          shopPreviewSkinId = null;
          setupHubWorld();
          rebuildShopStands();
          setMenuView('main');
          shopMessage = '';
          shopMessageTime = 0;
        }
      }
    }

    function handlePointerSelect(clientX, clientY) {
      const r = canvas.getBoundingClientRect();
      const sx = (clientX - r.left) * (canvas.width / r.width);
      const sy = (clientY - r.top) * (canvas.height / r.height);

      if (screen === 'play' && !evoTargeting) {
        for (const b of getHudButtons()) {
          if (sx >= b.x && sx <= b.x + b.w && sy >= b.y && sy <= b.y + b.h) {
            if (b.id === 'settings') {
              sfxClick();
              settingsOpen = !settingsOpen;
            } else if (b.id === 'exit') {
              sfxClick();
              canvas.style.cursor = 'default';
              enterMenu();
            } else if (b.id === 'save') {
              sfxSelect();
              saveRunState();
              shopMessage = 'Saved run!';
              shopMessageTime = 1.2;
            } else if (b.id === 'load') {
              const ok = loadRunState();
              if (ok) {
                sfxSelect();
                shopMessage = 'Loaded run!';
                shopMessageTime = 1.2;
              } else {
                sfxDeny();
                shopMessage = 'No save found';
                shopMessageTime = 1.2;
              }
            }
            return;
          }
        }

        if (settingsOpen) {
          const sb = getSettingsButtons();
          const buttons = [sb.volMinus, sb.volPlus, sb.shakeToggle, sb.particlesToggle, sb.close];
          for (const b of buttons) {
            if (sx >= b.x && sx <= b.x + b.w && sy >= b.y && sy <= b.y + b.h) {
              if (b.id === 'close') {
                sfxClick();
                settingsOpen = false;
              } else if (b.id === 'volMinus') {
                sfxClick();
                sfxVolume = Math.max(0, Math.min(1, Math.round((sfxVolume - 0.1) * 10) / 10));
                saveSettings();
              } else if (b.id === 'volPlus') {
                sfxClick();
                sfxVolume = Math.max(0, Math.min(1, Math.round((sfxVolume + 0.1) * 10) / 10));
                saveSettings();
              } else if (b.id === 'shake') {
                sfxClick();
                shakeEnabled = !shakeEnabled;
                if (!shakeEnabled) { shakeTime = 0; shakeStrength = 0; }
                saveSettings();
              } else if (b.id === 'particles') {
                sfxClick();
                particlesEnabled = !particlesEnabled;
                if (!particlesEnabled) particles.length = 0;
                saveSettings();
              }
              return;
            }
          }
        }
      }

      if (screen !== 'menu' && !evoTargeting) return;
      updatePointerWorld(clientX, clientY);
      const wx = pointerWorldX;
      const wy = pointerWorldY;

      if (evoTargeting) {
        evoTargeting = false;
        canvas.style.cursor = 'default';
        evoTargetX = wx - player.w * 0.5;
        evoTargetY = wy - player.h * 0.5;
        evoBurstReady = false;
        evoBurstWait = 0;
        evoTeleportUses = 0;
        const sx = player.x;
        const sy = player.y;
        const tx = evoTargetX;
        const ty = evoTargetY;
        const dx = tx - sx;
        const dy = ty - sy;
        const dist = Math.hypot(dx, dy) || 1;
        const px = -dy / dist;
        const py = dx / dist;
        const amp = Math.min(180, Math.max(70, dist * 0.22));
        evoDashPts.length = 0;
        evoDashPts.push({ x: sx + dx * 0.33, y: sy + dy * 0.33 + 60 });
        evoDashPts.push({ x: sx + dx * 0.66, y: sy + dy * 0.66 - 60 });
        evoDashPts.push({ x: tx, y: ty });
        evoDashStep = 0;
        evoDashTimer = 0;
        evoDashActive = true;
        spawnParticles('smoke', player.x + player.w * 0.5, player.y + player.h * 0.6, 22);
        return;
      }

      for (const z of menuZones) {
        if (pointInRect(wx, wy, z)) {
          activateMenuZoneId(z.id);
          return;
        }
      }
      if (menuView === 'shop') {
        for (const st of shopStands) {
          if (pointInRect(wx, wy, st)) {
            activateShopSkinId(st.skinId);
            return;
          }
        }
      }
    }

    canvas.addEventListener('mousedown', (e) => {
      ensureAudio();
      handlePointerSelect(e.clientX, e.clientY);
    });
    canvas.addEventListener('mousemove', (e) => {
      updatePointerWorld(e.clientX, e.clientY);
    });
    canvas.addEventListener('mouseleave', () => {
      pointerActive = false;
    });
    canvas.addEventListener('touchstart', (e) => {
      ensureAudio();
      if (evoTargeting || settingsOpen || screen !== 'play') {
        const t = e.touches[0];
        handlePointerSelect(t.clientX, t.clientY);
        return;
      }
      syncTouchKeysFromTouches(e.touches);
      const r = canvas.getBoundingClientRect();
      const t0 = e.touches[0];
      const sx = (t0.clientX - r.left) * (canvas.width / r.width);
      const sy = (t0.clientY - r.top) * (canvas.height / r.height);
      const btn = keyForMobileButtonAt(sx, sy);
      if (!btn) handlePointerSelect(t0.clientX, t0.clientY);
    }, { passive: true });

    canvas.addEventListener('touchmove', (e) => {
      syncTouchKeysFromTouches(e.touches);
    }, { passive: true });

    canvas.addEventListener('touchend', (e) => {
      syncTouchKeysFromTouches(e.touches);
    }, { passive: true });

    canvas.addEventListener('touchcancel', (e) => {
      syncTouchKeysFromTouches(e.touches);
    }, { passive: true });

    // World
    const gravity = 2000; // px/s^2 (harder)
    const moveAccel = 2200; // px/s^2
    const maxSpeedX = 400; // px/s
    const frictionGround = 1400; // px/s^2
    const jumpSpeed = 660; // px/s (slightly lower, harder)
    const coyoteTime = 0.1;
    const jumpBufferTime = 0.12;

    const urlParams = new URLSearchParams(window.location.search);
    const modeParam = urlParams.get('mode');
    let gameMode = (modeParam || 'classic').toLowerCase();
    let noCheckpointsMode = gameMode === 'nocp' || gameMode === 'no-checkpoint' || gameMode === 'ncp';
    let modeLabel = noCheckpointsMode ? 'No-Checkpoint' : 'Checkpoints';
    screen = modeParam ? 'play' : 'menu';

    const COINS_KEY = 'parkour_coins';
    const SAVE_STATE_KEY = 'parkour_saveState_v1';
    let coins = 0;
    try {
      coins = parseInt(localStorage.getItem(COINS_KEY) || '0', 10) || 0;
    } catch (e) {
      coins = 0;
    }

    let runStartCoins = coins;
    let deathsThisRun = 0;

    function mulberry32(a) {
      return function() {
        let t = a += 0x6D2B79F5;
        t = Math.imul(t ^ (t >>> 15), t | 1);
        t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
        return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
      };
    }

    function getIsoWeekYearAndWeek(d) {
      const dt = new Date(Date.UTC(d.getFullYear(), d.getMonth(), d.getDate()));
      const dayNum = dt.getUTCDay() || 7;
      dt.setUTCDate(dt.getUTCDate() + 4 - dayNum);
      const yearStart = new Date(Date.UTC(dt.getUTCFullYear(), 0, 1));
      const weekNo = Math.ceil((((dt - yearStart) / 86400000) + 1) / 7);
      return { year: dt.getUTCFullYear(), week: weekNo };
    }

    function getDailySeed() {
      const d = new Date();
      return d.getFullYear() * 10000 + (d.getMonth() + 1) * 100 + d.getDate();
    }

    function getWeeklySeed() {
      const d = new Date();
      const { year, week } = getIsoWeekYearAndWeek(d);
      return year * 100 + week;
    }

    let rng = Math.random;
    let challengeId = 'none';
    let challengeSeed = 0;

    let runTeleports = 0;
    let runPowerups = 0;
    let runCheckpoints = 0;
    let runSurvivalTime = 0;

    let missions = [];
    let missionToast = '';
    let missionToastTime = 0;

    function saveMissionCompletion(seed, id) {
      const key = `parkour_missions_done_${seed}`;
      let arr = [];
      try { arr = JSON.parse(localStorage.getItem(key) || '[]'); } catch (e) { arr = []; }
      if (!Array.isArray(arr)) arr = [];
      if (!arr.includes(id)) arr.push(id);
      try { localStorage.setItem(key, JSON.stringify(arr)); } catch (e) {}
    }

    function isMissionDone(seed, id) {
      const key = `parkour_missions_done_${seed}`;
      let arr = [];
      try { arr = JSON.parse(localStorage.getItem(key) || '[]'); } catch (e) { arr = []; }
      if (!Array.isArray(arr)) return false;
      return arr.includes(id);
    }

    function initMissionsForSeed(seed) {
      const r = mulberry32((seed ^ 0x9e3779b9) >>> 0);
      const pool = [
        { type: 'dist', name: 'Reach distance', targets: [4000, 7000, 10000], reward: 60 },
        { type: 'tele', name: 'Use teleports', targets: [3, 6, 9], reward: 70 },
        { type: 'power', name: 'Collect double-jumps', targets: [1, 2, 3], reward: 60 },
        { type: 'survive', name: 'Survive (seconds)', targets: [35, 55, 75], reward: 80 },
        { type: 'nodeaths', name: 'No deaths (seconds)', targets: [45, 70, 100], reward: 120 },
      ];
      const picked = [];
      while (picked.length < 3) {
        const idx = Math.floor(r() * pool.length);
        const cand = pool[idx];
        if (picked.some(p => p.type === cand.type)) continue;
        const tier = Math.floor(r() * cand.targets.length);
        const target = cand.targets[tier];
        const id = `${seed}:${cand.type}:${target}`;
        picked.push({ id, seed, type: cand.type, name: cand.name, target, reward: cand.reward, done: isMissionDone(seed, id) });
      }
      missions = picked;
    }

    function missionProgress(m) {
      if (m.type === 'dist') return Math.floor(maxReachedX);
      if (m.type === 'tele') return runTeleports;
      if (m.type === 'power') return runPowerups;
      if (m.type === 'survive') return Math.floor(runSurvivalTime);
      if (m.type === 'nodeaths') return Math.floor(runSurvivalTime);
      return 0;
    }

    function checkMissions() {
      if (!missions.length) return;
      for (const m of missions) {
        if (m.done) continue;
        const prog = missionProgress(m);
        const ok = (m.type === 'nodeaths') ? (deathsThisRun === 0 && prog >= m.target) : (prog >= m.target);
        if (ok) {
          m.done = true;
          saveMissionCompletion(m.seed, m.id);
          addCoins(m.reward);
          sfxCoin();
          missionToast = `Mission complete! +${m.reward} coins`;
          missionToastTime = 1.1;
        }
      }
    }

    const SKINS = [
      { id: 'none', name: 'Nothing', price: 0, type: 'base', body: '#111', accent: '#3b82f6' },
      { id: 'ninja', name: 'Ninja', price: 500, type: 'power', body: '#050505', accent: '#ef4444', desc: 'Swift movement and higher jumps. Use Teleport (E) to dash through danger.' },
      { id: 'evo-ninja', name: 'Evo Ninja', price: 800, type: 'power', body: '#090014', accent: '#a855f7', desc: 'Evil shadow ninja. Teleport cooldown -5s. After 3 teleports, wait 10s then press G to target a triple zig-zag teleport.', reqBestDist: 12000, reqSkin: 'ninja' },
      { id: 'monks', name: 'Monks', price: 500, type: 'power', body: '#f8fafc', accent: '#f59e0b', desc: 'Blessed feet: infinite double-jump. No jump shake, silent landings.' },
      { id: 'iron-golem', name: 'Iron Golem', price: 500, type: 'power', body: '#374151', accent: '#1d4ed8', desc: 'Heavy body with a 4-hit shield vs spikes. Slow but powerful crashes.' },
      { id: 'knight', name: 'Knight', price: 200, type: 'cosmetic', body: '#9ca3af', accent: '#374151' },
      { id: 'prince', name: 'Prince', price: 200, type: 'cosmetic', body: '#fbbf24', accent: '#b45309' },
      { id: 'ember', name: 'Ember', price: 200, type: 'cosmetic', body: '#fb7185', accent: '#f97316' },
      { id: 'frost', name: 'Frost', price: 200, type: 'cosmetic', body: '#60a5fa', accent: '#22d3ee' },
    ];
    const UNLOCKED_SKINS_KEY = 'parkour_unlockedSkins';
    const SELECTED_SKIN_KEY = 'parkour_selectedSkin';
    let unlockedSkins = new Set(['none']);
    let selectedSkinId = 'none';
    try {
      const raw = JSON.parse(localStorage.getItem(UNLOCKED_SKINS_KEY) || '[]');
      if (Array.isArray(raw)) {
        for (const id of raw) if (typeof id === 'string') unlockedSkins.add(id);
      }
      const sel = localStorage.getItem(SELECTED_SKIN_KEY);
      if (sel) selectedSkinId = sel;
    } catch (e) {}
    function getSkin(id) { return SKINS.find(s => s.id === id) || SKINS[0]; }
    function isSkinUnlocked(id) { return unlockedSkins.has(id); }
    function saveSkins() {
      try {
        localStorage.setItem(UNLOCKED_SKINS_KEY, JSON.stringify(Array.from(unlockedSkins)));
        localStorage.setItem(SELECTED_SKIN_KEY, selectedSkinId);
      } catch (e) {}
    }
    if (!getSkin(selectedSkinId)) selectedSkinId = 'none';
    if (!isSkinUnlocked(selectedSkinId)) selectedSkinId = 'none';
    saveSkins();

    function setMode(mode) {
      gameMode = (mode || 'classic').toLowerCase();
      noCheckpointsMode = gameMode === 'nocp' || gameMode === 'no-checkpoint' || gameMode === 'ncp' || gameMode === 'daily' || gameMode === 'weekly';
      modeLabel = (gameMode === 'daily') ? 'Daily' : ((gameMode === 'weekly') ? 'Weekly' : (noCheckpointsMode ? 'No-Checkpoint' : 'Checkpoints'));

      bestScore = 0;
      bestDistance = 0;
      bestSaved = false;
      try {
        if (noCheckpointsMode) {
          bestScore = parseInt(localStorage.getItem(BEST_SCORE_KEY) || '0', 10) || 0;
          bestDistance = parseInt(localStorage.getItem(BEST_DISTANCE_KEY) || '0', 10) || 0;
        }
      } catch (e) {
        bestScore = 0;
        bestDistance = 0;
      }
      bestDistanceStart = bestDistance;
      bestDistanceBeaten = false;
    }

    let score = 0;
    let bestScore = 0;
    let bestDistance = 0;
    let bestSaved = false;
    let bestDistanceStart = 0;
    let bestDistanceBeaten = false;
    let bestDistAnimTime = 0;
    const bestDistAnimDuration = 0.9;
    const BEST_SCORE_KEY = 'parkour_nocp_bestScore';
    const BEST_DISTANCE_KEY = 'parkour_nocp_bestDistance';
    const BEST_DISTANCE_ALL_KEY = 'parkour_bestDistance';
    let bestDistanceAll = 0;
    try {
      bestDistanceAll = parseInt(localStorage.getItem(BEST_DISTANCE_ALL_KEY) || '0', 10) || 0;
    } catch (e) {
      bestDistanceAll = 0;
    }
    setMode(gameMode);

    const player = { x: 60, y: 0, w: 40, h: 50, vx: 0, vy: 0, onGround: false, color: '#111' };
    let facing = 1;
    let jumpsLeft = 1;
    let hasDoubleJump = false;
    let doubleJumpTimer = 0; // seconds remaining when active
    let jumpHeld = false; // for edge detection
    let teleportHeld = false;
    let escapeHeld = false;
    let teleportCooldown = 0;
    let teleportFxTime = 0;
    const teleportFxDuration = 0.22;
    let teleportFrom = { x: 0, y: 0 };
    let teleportTo = { x: 0, y: 0 };
    let gHeld = false;
    let evoTeleportUses = 0;
    let evoBurstWait = 0;
    let evoBurstReady = false;
    let evoTargeting = false;
    let evoTargetX = 0;
    let evoTargetY = 0;
    let evoDashActive = false;
    let evoDashStep = 0;
    let evoDashTimer = 0;
    const evoDashPts = [];
    let evoSmokeTimer = 0;
    let doubleJumpAura = 0;
    let golemLives = 4;
    let golemInvuln = 0;
    let golemHitFlash = 0;
    let shopMessage = '';
    let shopMessageTime = 0;
    let coinToast = '';
    let coinToastTime = 0;
    let coyoteTimer = 0;
    let jumpBufferTimer = 0;
    let interactLatch = 0;

    function saveCoins() {
      try { localStorage.setItem(COINS_KEY, String(coins)); } catch (e) {}
    }

    function addCoins(n) {
      if (!n) return;
      coins += n;
      if (coins < 0) coins = 0;
      saveCoins();
    }

    function getHudButtons() {
      const pad = 12;
      const gap = 10;
      const w = 86;
      const h = 34;
      const y = 12;
      const x4 = canvas.width - pad - w;
      const x3 = x4 - gap - w;
      const x2 = x3 - gap - w;
      const x1 = x2 - gap - w;
      return [
        { id: 'settings', label: 'SET', x: x1, y, w, h },
        { id: 'exit', label: 'EXIT', x: x2, y, w, h },
        { id: 'save', label: 'SAVE', x: x3, y, w, h },
        { id: 'load', label: 'LOAD', x: x4, y, w, h },
      ];
    }

    function getSettingsButtons() {
      const w = 560;
      const h = 300;
      const x = Math.floor(canvas.width * 0.5 - w * 0.5);
      const y = Math.floor(canvas.height * 0.5 - h * 0.5);

      const btnW = 54;
      const btnH = 34;
      const left = x + 24;
      const top = y + 70;
      const rowH = 54;

      const volMinus = { id: 'volMinus', x: left + 210, y: top + 0, w: btnW, h: btnH };
      const volPlus = { id: 'volPlus', x: left + 210 + btnW + 10, y: top + 0, w: btnW, h: btnH };
      const shakeToggle = { id: 'shake', x: left + 210, y: top + rowH, w: 150, h: btnH };
      const particlesToggle = { id: 'particles', x: left + 210, y: top + rowH * 2, w: 150, h: btnH };
      const close = { id: 'close', x: x + w - 24 - 110, y: y + h - 24 - 36, w: 110, h: 36 };

      return { panel: { x, y, w, h }, volMinus, volPlus, shakeToggle, particlesToggle, close };
    }

    function saveRunState() {
      const data = {
        v: 1,
        gameMode,
        noCheckpointsMode,
        modeLabel,
        selectedSkinId,
        bestScore,
        bestDistance,
        bestSaved,
        bestDistanceStart,
        bestDistanceBeaten,
        bestDistAnimTime,
        player,
        facing,
        jumpsLeft,
        hasDoubleJump,
        doubleJumpTimer,
        teleportCooldown,
        teleportFxTime,
        teleportFrom,
        teleportTo,
        evoTeleportUses,
        evoBurstWait,
        evoBurstReady,
        evoTargeting,
        evoTargetX,
        evoTargetY,
        evoDashActive,
        evoDashStep,
        evoDashTimer,
        evoDashPts,
        evoSmokeTimer,
        doubleJumpAura,
        golemLives,
        golemInvuln,
        golemHitFlash,
        coyoteTimer,
        jumpBufferTimer,
        lastCheckpoint,
        maxReachedX,
        nextSpawnX,
        chunksSpawned,
        checkpointFlashTime,
        platforms,
        hazards,
        checkpoints,
        powerups,
      };
      try {
        localStorage.setItem(SAVE_STATE_KEY, JSON.stringify(data));
      } catch (e) {}
    }

    function loadRunState() {
      let raw = null;
      try {
        raw = localStorage.getItem(SAVE_STATE_KEY);
      } catch (e) {
        raw = null;
      }
      if (!raw) return false;
      let data = null;
      try {
        data = JSON.parse(raw);
      } catch (e) {
        data = null;
      }
      if (!data || data.v !== 1) return false;

      gameMode = (data.gameMode || 'classic').toLowerCase();
      noCheckpointsMode = !!data.noCheckpointsMode;
      modeLabel = data.modeLabel || (noCheckpointsMode ? 'No-Checkpoint' : 'Checkpoints');
      selectedSkinId = data.selectedSkinId || selectedSkinId;
      score = 0;
      bestScore = data.bestScore || 0;
      bestDistance = data.bestDistance || 0;
      bestSaved = !!data.bestSaved;
      bestDistanceStart = data.bestDistanceStart || 0;
      bestDistanceBeaten = !!data.bestDistanceBeaten;
      bestDistAnimTime = data.bestDistAnimTime || 0;

      if (data.player) {
        player.x = data.player.x || 0;
        player.y = data.player.y || 0;
        player.w = data.player.w || player.w;
        player.h = data.player.h || player.h;
        player.vx = data.player.vx || 0;
        player.vy = data.player.vy || 0;
        player.onGround = !!data.player.onGround;
      }
      facing = data.facing || 1;
      jumpsLeft = data.jumpsLeft || 1;
      hasDoubleJump = !!data.hasDoubleJump;
      doubleJumpTimer = data.doubleJumpTimer || 0;
      teleportCooldown = data.teleportCooldown || 0;
      teleportFxTime = data.teleportFxTime || 0;
      teleportFrom = data.teleportFrom || teleportFrom;
      teleportTo = data.teleportTo || teleportTo;
      evoTeleportUses = data.evoTeleportUses || 0;
      evoBurstWait = data.evoBurstWait || 0;
      evoBurstReady = !!data.evoBurstReady;
      evoTargeting = !!data.evoTargeting;
      evoTargetX = data.evoTargetX || 0;
      evoTargetY = data.evoTargetY || 0;
      evoDashActive = !!data.evoDashActive;
      evoDashStep = data.evoDashStep || 0;
      evoDashTimer = data.evoDashTimer || 0;
      evoDashPts.length = 0;
      if (Array.isArray(data.evoDashPts)) {
        for (const p of data.evoDashPts) {
          if (p && typeof p.x === 'number' && typeof p.y === 'number') evoDashPts.push({ x: p.x, y: p.y });
        }
      }
      evoSmokeTimer = data.evoSmokeTimer || 0;
      doubleJumpAura = data.doubleJumpAura || 0;
      golemLives = (typeof data.golemLives === 'number') ? data.golemLives : 4;
      golemInvuln = data.golemInvuln || 0;
      golemHitFlash = data.golemHitFlash || 0;
      coyoteTimer = data.coyoteTimer || 0;
      jumpBufferTimer = data.jumpBufferTimer || 0;
      lastCheckpoint = data.lastCheckpoint || lastCheckpoint;
      maxReachedX = data.maxReachedX || 0;
      nextSpawnX = data.nextSpawnX || 0;
      chunksSpawned = data.chunksSpawned || 0;
      checkpointFlashTime = data.checkpointFlashTime || 0;
      platforms = Array.isArray(data.platforms) ? data.platforms : platforms;
      hazards = Array.isArray(data.hazards) ? data.hazards : hazards;
      checkpoints = Array.isArray(data.checkpoints) ? data.checkpoints : checkpoints;
      powerups = Array.isArray(data.powerups) ? data.powerups : powerups;

      screen = 'play';
      menuView = 'main';
      gameOver = false;
      deathTimer = 0;
      deathPieces = [];
      interactLatch = 0;
      evoTargeting = false;
      evoDashActive = false;
      jumpHeld = false;
      teleportHeld = false;
      gHeld = false;
      canvas.style.cursor = 'default';
      return true;
    }

    function rebuildShopStands() {
      shopStands.length = 0;
      const items = SKINS;
      const h = canvas.height;
      const baseY = h - 40;
      let x = 140;
      for (const s of items) {
        shopStands.push({
          skinId: s.id,
          x,
          y: baseY - 190,
          w: 160,
          h: 72,
        });
        x += 220;
      }
    }

    // Procedural infinite level
    function ground(y) { return { x: -1e6, y, w: 2e6, h: 40, type: 'ground' }; }
    let platforms = [];
    let hazards = [];
    let checkpoints = [];
    let powerups = []; // double-jump powerups
    let nextSpawnX = 0;
    let lastCheckpoint = { x: 60, y: 0 };
    let maxReachedX = 0;
    let chunksSpawned = 0;
    let checkpointFlashTime = 0; // seconds for 'checkpoint saved' flash

    function resetWorld() {
      platforms = [];
      hazards = [];
      checkpoints = [];
      powerups = [];
      nextSpawnX = 0;
      chunksSpawned = 0;
      const h = canvas.height;
      // Infinite ground band
      platforms.push(ground(h - 40));
      // Seed a few starting platforms
      spawnChunk();
      spawnChunk();
    }

    function difficultyAt(x) {
      // Increase from 0 -> 1 as distance grows (faster ramp)
      return Math.min(1, x / 3000);
    }

    function spawnChunk() {
      const h = canvas.height;
      const baseY = h - 40;
      const chunkW = 900;
      const startX = nextSpawnX;
      const d = Math.min(1, startX / 18000);
 // generate about one screen at a time
      let x = nextSpawnX + 100;
      let cursorY = baseY - 140;
      while (x < nextSpawnX + chunkW) {
        // Platform sizes/gaps scale with difficulty
        const platW = Math.max(70, 210 - Math.floor(150 * d) + Math.floor(rng() * 40));
        const gap = Math.min(520, 260 + Math.floor(260 * d) + Math.floor(rng() * 160));
        // Vary height a bit
        const dy = (rng() - 0.5) * (120 + 120 * d);
        cursorY = Math.min(baseY - 80, Math.max(baseY - 360, cursorY + dy));
        const plat = { x, y: cursorY, w: platW, h: 20, type: 'plat' };
        const movingChance = 0.10 + 0.10 * d;
        const bounceChance = 0.07 + 0.07 * d;
        const r0 = rng();
        if (r0 < bounceChance) {
          plat.type = 'bounce';
        } else if (r0 < bounceChance + movingChance) {
          plat.type = 'moving';
          plat.baseX = plat.x;
          plat.amp = 40 + rng() * 110;
          plat.freq = 0.6 + rng() * 0.9;
          plat.phase = rng() * Math.PI * 2;
        }
        platforms.push(plat);
        // Occasionally add a hazard between platforms on ground
        if (rng() < 0.5 + 0.5 * d) {
          const hzW = 40 + Math.floor(rng() * 60);
          hazards.push({ x: x + platW + (gap - hzW) / 2, y: baseY - 20, w: hzW, h: 20 });
        }
        // Occasionally add a powerup on top of a platform
        if (rng() < 0.18 + 0.25 * d) {
          powerups.push({ x: plat.x + Math.floor(plat.w/2) - 10, y: plat.y - 20, w: 20, h: 20, type: 'double' });
        }
        x += platW + gap;
      }
      // Add a checkpoint less frequently (every 3 chunks)
      const cpX = nextSpawnX + chunkW - 60;
      chunksSpawned++;
      if (!noCheckpointsMode && chunksSpawned % 3 === 0) {
        checkpoints.push({ x: cpX, y: baseY - 100, w: 16, h: 60 });
      }
      nextSpawnX += chunkW;
    }

    function ensureWorldAhead() {
      while (nextSpawnX < camera.x + canvas.width * 2) {
        spawnChunk();
      }
    }

    // Camera
    const camera = { x: 0, y: 0 };

    let t = 0;
    let shakeTime = 0;
    let shakeStrength = 0;
    const particles = [];
    const trail = [];

    function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }
    function lerp(a, b, t) { return a + (b - a) * t; }
    function rand(a, b) { return a + Math.random() * (b - a); }
    function hexToRgb(hex) {
      const h = hex.replace('#', '');
      const n = parseInt(h.length === 3 ? h.split('').map(c => c + c).join('') : h, 16);
      return { r: (n >> 16) & 255, g: (n >> 8) & 255, b: n & 255 };
    }
    function rgba(hex, a) {
      const c = hexToRgb(hex);
      return `rgba(${c.r},${c.g},${c.b},${a})`;
    }

    function worldToScreenX(x) { return Math.floor(x - camera.x); }
    function worldToScreenY(y) { return Math.floor(y - camera.y); }

    function roundRectPath(x, y, w, h, r) {
      const rr = Math.min(r, w / 2, h / 2);
      ctx.beginPath();
      ctx.moveTo(x + rr, y);
      ctx.arcTo(x + w, y, x + w, y + h, rr);
      ctx.arcTo(x + w, y + h, x, y + h, rr);
      ctx.arcTo(x, y + h, x, y, rr);
      ctx.arcTo(x, y, x + w, y, rr);
      ctx.closePath();
    }

    function spawnParticles(type, x, y, amount) {
      if (!particlesEnabled) return;
      const base = type === 'power' ? '#06b6d4' : (type === 'land' ? '#6b7280' : (type === 'smoke' ? '#a855f7' : '#ffffff'));
      for (let i = 0; i < amount; i++) {
        const ang = type === 'smoke' ? rand(-Math.PI * 0.85, -Math.PI * 0.15) : rand(-Math.PI, 0);
        const spd = type === 'power' ? rand(80, 190) : (type === 'land' ? rand(140, 360) : (type === 'smoke' ? rand(40, 120) : rand(100, 260)));
        const vx = Math.cos(ang) * spd * rand(0.5, 1.2);
        const vy = Math.sin(ang) * spd * rand(0.4, 1.1);
        const ttl = type === 'power' ? rand(0.5, 1.2) : (type === 'land' ? rand(0.3, 0.7) : (type === 'smoke' ? rand(0.6, 1.25) : rand(0.25, 0.6)));
        particles.push({ x, y, vx, vy, life: ttl, ttl, size: rand(type === 'smoke' ? 5 : 2, type === 'land' ? 6 : (type === 'smoke' ? 12 : 4)), color: base, gravity: type === 'power' ? -80 : (type === 'smoke' ? -180 : 900), drag: type === 'power' ? 0.88 : (type === 'smoke' ? 0.9 : 0.82) });
      }
    }

    function updateParticles(dt) {
      if (!particlesEnabled) { particles.length = 0; return; }
      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.life -= dt;
        if (p.life <= 0) { particles.splice(i, 1); continue; }
        p.vx *= Math.pow(p.drag, dt * 60);
        p.vy *= Math.pow(p.drag, dt * 60);
        p.vy += p.gravity * dt;
        p.x += p.vx * dt;
        p.y += p.vy * dt;
      }
    }

    function rectsOverlap(a, b) {
      return !(a.x + a.w <= b.x || a.x >= b.x + b.w || a.y + a.h <= b.y || a.y >= b.y + b.h);
    }

    function getGroundPlatform() {
      const py = player.y + player.h;
      for (const s of platforms) {
        if (py < s.y - 2 || py > s.y + 3) continue;
        if (player.x + player.w <= s.x || player.x >= s.x + s.w) continue;
        return s;
      }
      return null;
    }

    function updateDynamicPlatforms() {
      const groundPlat = player.onGround ? getGroundPlatform() : null;
      for (const s of platforms) {
        if (s.type !== 'moving') continue;
        const prevX = s.x;
        s.x = s.baseX + Math.sin(t * s.freq + s.phase) * s.amp;
        const dx = s.x - prevX;
        if (dx && groundPlat === s) {
          player.x += dx;
          if (player.x < 0) player.x = 0;
        }
      }
    }

    function resolveCollisions(p, dt) {
      p.onGround = false;
      // Sweep horizontally then vertically
      p.x += p.vx * dt;
      for (const s of platforms) {
        if (!rectsOverlap(p, s)) continue;
        if (p.vx > 0) {
          p.x = s.x - p.w;
        } else if (p.vx < 0) {
          p.x = s.x + s.w;
        }
        p.vx = 0;
      }
      p.y += p.vy * dt;
      for (const s of platforms) {
        if (!rectsOverlap(p, s)) continue;
        if (p.vy > 0) {
          p.y = s.y - p.h;
          p.vy = 0;
          p.onGround = true;
        } else if (p.vy < 0) {
          p.y = s.y + s.h;
          p.vy = 0;
        }
      }
    }

    let gameOver = false;
    let deathTimer = 0;
    const deathDuration = 0.9;
    let deathPieces = [];
    let deathCamX = 0;
    let deathCamY = 0;

    function triggerDeath() {
      if (gameOver) return;
      deathsThisRun += 1;
      gameOver = true;
      deathTimer = 0;
      deathCamX = camera.x;
      deathCamY = camera.y;
      deathPieces = [];
      sfxDeath();
      const cols = 6;
      const rows = 7;
      const pw = player.w / cols;
      const ph = player.h / rows;
      for (let cy = 0; cy < rows; cy++) {
        for (let cx = 0; cx < cols; cx++) {
          const px = player.x + cx * pw;
          const py = player.y + cy * ph;
          const dx = (cx - (cols - 1) / 2) / ((cols - 1) / 2);
          const dy = (cy - (rows - 1) / 2) / ((rows - 1) / 2);
          const spd = rand(220, 620);
          deathPieces.push({
            x: px,
            y: py,
            w: pw,
            h: ph,
            vx: dx * spd + rand(-120, 120),
            vy: dy * spd + rand(-520, -220),
            rot: rand(-1.6, 1.6),
            vr: rand(-7, 7),
          });
        }
      }
      spawnParticles('land', player.x + player.w * 0.5, player.y + player.h * 0.5, 36);
      shakeTime = 0.18;
      shakeStrength = Math.max(shakeStrength, 6);
    }

    function updateDeath(dt) {
      deathTimer += dt;
      for (const p of deathPieces) {
        p.vy += 2200 * dt;
        p.vx *= Math.pow(0.92, dt * 60);
        p.vy *= Math.pow(0.92, dt * 60);
        p.x += p.vx * dt;
        p.y += p.vy * dt;
        p.rot += p.vr * dt;
      }
      camera.x = deathCamX;
      camera.y = deathCamY;
    }

    function hardReset() {
      // Full reset back to start
      lastCheckpoint = { x: 60, y: 0 };
      maxReachedX = 0;
      player.x = lastCheckpoint.x; player.y = lastCheckpoint.y; player.vx = 0; player.vy = 0; player.onGround = false;
      gameOver = false;
      deathTimer = 0;
      deathPieces = [];
      score = 0;

      runStartCoins = coins;
      deathsThisRun = 0;
      runTeleports = 0;
      runPowerups = 0;
      runCheckpoints = 0;
      runSurvivalTime = 0;
      missionToast = '';
      missionToastTime = 0;

      bestSaved = false;
      bestDistanceStart = bestDistance;
      bestDistanceBeaten = false;
      bestDistAnimTime = 0;
      teleportCooldown = 0;
      teleportFxTime = 0;
      golemLives = 4;
      golemInvuln = 0;
      golemHitFlash = 0;
      shopMessage = '';
      shopMessageTime = 0;
      hasDoubleJump = false; doubleJumpTimer = 0; jumpsLeft = 1; jumpHeld = false; checkpointFlashTime = 0;
      coyoteTimer = 0; jumpBufferTimer = 0;
      resetWorld();
    }

    function respawnAtCheckpoint() {
      player.x = lastCheckpoint.x;
      player.y = lastCheckpoint.y;
      player.vx = 0; player.vy = 0; player.onGround = false;
      gameOver = false; jumpHeld = false; // don't trigger jump immediately
      deathTimer = 0;
      deathPieces = [];
      bestDistAnimTime = 0;
      teleportCooldown = 0;
      teleportFxTime = 0;
      golemLives = 4;
      golemInvuln = 0;
      golemHitFlash = 0;
      coyoteTimer = 0; jumpBufferTimer = 0;
    }

    function setupHubWorld() {
      platforms = [];
      hazards = [];
      checkpoints = [];
      powerups = [];
      nextSpawnX = 0;
      chunksSpawned = 0;
      menuZones.length = 0;
      const h = canvas.height;
      const baseY = h - 40;
      platforms.push(ground(baseY));
      camera.x = 0;
      camera.y = 0;
    }

    function setupShopWorld() {
      platforms = [];
      hazards = [];
      checkpoints = [];
      powerups = [];
      nextSpawnX = 0;
      chunksSpawned = 0;
      const h = canvas.height;
      const baseY = h - 40;
      platforms.push(ground(baseY));
      platforms.push({ x: 220, y: baseY - 120, w: 240, h: 20, type: 'plat' });
      platforms.push({ x: 520, y: baseY - 200, w: 220, h: 20, type: 'plat' });
      platforms.push({ x: 820, y: baseY - 280, w: 240, h: 20, type: 'plat' });
      platforms.push({ x: 1140, y: baseY - 200, w: 220, h: 20, type: 'plat' });
      powerups.push({ x: 330, y: baseY - 160, w: 20, h: 20, type: 'double' });
      hazards.push({ x: 720, y: baseY - 20, w: 120, h: 20 });
      camera.x = 0;
      camera.y = 0;
    }

    function shopRespawn() {
      const h = canvas.height;
      const baseY = h - 40;
      player.x = 140;
      player.y = baseY - player.h - 2;
      player.vx = 0;
      player.vy = 0;
      player.onGround = false;
      jumpsLeft = 1;
      hasDoubleJump = false;
      if (getSkin(selectedSkinId).id === 'monks') {
        doubleJumpTimer = 0;
        jumpsLeft = 999;
      } else {
        doubleJumpTimer = 0;
      }
      coyoteTimer = 0;
      jumpBufferTimer = 0;
      golemLives = 4;
      golemInvuln = 0;
      golemHitFlash = 0;
      teleportCooldown = 0;
      teleportFxTime = 0;
      jumpHeld = false;
      teleportHeld = false;
      gHeld = false;
      evoTargeting = false;
      evoDashActive = false;
      evoBurstReady = false;
      evoBurstWait = 0;
      evoTeleportUses = 0;
      canvas.style.cursor = 'default';
      camera.x = 0;
      camera.y = 0;
    }

    function setMenuView(view) {
      menuView = view;
      menuZones.length = 0;
      const h = canvas.height;
      const baseY = h - 40;
      if (menuView === 'main') {
        menuZones.push({ id: 'playClassic', label: 'PLAY\n(Checkpoints)', x: 220, y: baseY - 92, w: 180, h: 72 });
        menuZones.push({ id: 'playNoCP', label: 'PLAY\n(No-Checkpoint)', x: 430, y: baseY - 92, w: 210, h: 72 });
        menuZones.push({ id: 'playDaily', label: 'DAILY', x: 220, y: baseY - 172, w: 200, h: 60 });
        menuZones.push({ id: 'playWeekly', label: 'WEEKLY', x: 430, y: baseY - 172, w: 210, h: 60 });
        menuZones.push({ id: 'openSkinsShop', label: 'SKINS SHOP', x: 220, y: baseY - 252, w: 420, h: 60 });
      } else {
        menuZones.push({ id: 'backToMain', label: 'BACK', x: 220, y: baseY - 92, w: 140, h: 60 });
      }
    }

    function enterMenu() {
      screen = 'menu';
      setMode('classic');
      setupHubWorld();
      rebuildShopStands();
      setMenuView('main');
      const h = canvas.height;
      const baseY = h - 40;
      player.x = 140;
      player.y = baseY - player.h - 2;
      player.vx = 0;
      player.vy = 0;
      jumpsLeft = 1;
      hasDoubleJump = false;
      doubleJumpTimer = 0;
      coyoteTimer = 0;
      jumpBufferTimer = 0;
      gameOver = false;
      deathTimer = 0;
      deathPieces = [];
      interactLatch = 0;
      golemLives = 4;
      golemInvuln = 0;
      golemHitFlash = 0;
      teleportCooldown = 0;
      teleportFxTime = 0;
    }

    function startGame(mode) {
      screen = 'play';
      setMode(mode);
      if (gameMode === 'daily') {
        challengeId = 'daily';
        challengeSeed = getDailySeed();
        rng = mulberry32((challengeSeed >>> 0) || 1);
        initMissionsForSeed(challengeSeed);
      } else if (gameMode === 'weekly') {
        challengeId = 'weekly';
        challengeSeed = getWeeklySeed();
        rng = mulberry32((challengeSeed >>> 0) || 1);
        initMissionsForSeed(challengeSeed);
      } else {
        challengeId = 'none';
        challengeSeed = 0;
        rng = Math.random;
        missions = [];
      }
      hardReset();
    }

    function updateHub(dt) {
      const skin = getSkin(selectedSkinId);
      const isEvo = skin.id === 'evo-ninja';
      const isNinja = skin.id === 'ninja' || isEvo;
      const isMonks = skin.id === 'monks';
      const isGolem = skin.id === 'iron-golem';

      let accel = moveAccel;
      let maxSp = maxSpeedX;
      let jSp = jumpSpeed;
      if (isNinja) { accel *= 1.3; maxSp *= 1.35; jSp *= 1.25; }


      if (teleportCooldown > 0) teleportCooldown = Math.max(0, teleportCooldown - dt);
      if (teleportFxTime > 0) teleportFxTime = Math.max(0, teleportFxTime - dt);
      if (golemInvuln > 0) golemInvuln = Math.max(0, golemInvuln - dt);
      if (golemHitFlash > 0) golemHitFlash = Math.max(0, golemHitFlash - dt);
      if (shopMessageTime > 0) shopMessageTime = Math.max(0, shopMessageTime - dt);
      if (doubleJumpAura > 0) doubleJumpAura = Math.max(0, doubleJumpAura - dt);

      if (isEvo) {
        if (evoBurstWait > 0) {
          evoBurstWait = Math.max(0, evoBurstWait - dt);
          if (evoBurstWait <= 0 && evoTeleportUses >= 3) evoBurstReady = true;
        }
      } else {
        evoTargeting = false;
        evoDashActive = false;
        evoBurstReady = false;
        evoBurstWait = 0;
        evoTeleportUses = 0;
        canvas.style.cursor = 'default';
      }

      if (isMonks) {
        hasDoubleJump = false;
        doubleJumpTimer = 0;
        if (player.onGround) jumpsLeft = 999;
        else jumpsLeft = Math.max(jumpsLeft, 2);
      }

      if (doubleJumpTimer > 0) {
        doubleJumpTimer -= dt;
        if (doubleJumpTimer <= 0) { doubleJumpTimer = 0; hasDoubleJump = false; if (jumpsLeft > 1) jumpsLeft = 1; }
      }

      const left = keys.has('a') || keys.has('arrowleft');
      const right = keys.has('d') || keys.has('arrowright');
      const jumpPressed = keys.has(' ') || keys.has('arrowup') || keys.has('w');
      const jumpEdge = jumpPressed && !jumpHeld;
      jumpHeld = jumpPressed;
      if (jumpEdge) jumpBufferTimer = jumpBufferTime;

      const teleportPressed = keys.has('e');
      const teleportEdge = teleportPressed && !teleportHeld;
      teleportHeld = teleportPressed;

      const gPressed = keys.has('g');
      const gEdge = gPressed && !gHeld;
      gHeld = gPressed;
      if (isEvo && gEdge && evoBurstReady && !evoTargeting && !evoDashActive && !gameOver) {
        evoTargeting = true;
        canvas.style.cursor = 'crosshair';
      }

      if (evoDashActive) {
        evoDashTimer -= dt;
        while (evoDashActive && evoDashTimer <= 0) {
          const fromX = player.x;
          const fromY = player.y;
          const pt = evoDashPts[evoDashStep];
          teleportFrom.x = fromX;
          teleportFrom.y = fromY;
          player.x = pt.x;
          player.y = pt.y;
          player.vx = 0;
          player.vy = 0;
          for (let k = 0; k < 6; k++) {
            let minY = Infinity;
            for (const s of platforms) {
              if (rectsOverlap(player, s)) minY = Math.min(minY, s.y - player.h - 2);
            }
            if (minY !== Infinity) player.y = minY;
            else break;
          }
          teleportTo.x = player.x;
          teleportTo.y = player.y;
          teleportFxTime = teleportFxDuration;
          sfxTeleport();
          spawnParticles('power', player.x + player.w * 0.5, player.y + player.h * 0.5, 18);
          spawnParticles('smoke', player.x + player.w * 0.5, player.y + player.h * 0.6, 14);
          shakeTime = 0.10;
          shakeStrength = Math.max(shakeStrength, 4);
          evoDashStep += 1;
          evoDashTimer = 0.09;
          if (evoDashStep >= 3) {
            evoDashActive = false;
            break;
          }
        }
      }

      if (isEvo) {
        evoSmokeTimer -= dt;
        if (evoSmokeTimer <= 0) {
          evoSmokeTimer = 0.07;
          spawnParticles('smoke', player.x + player.w * 0.5, player.y + player.h * 0.75, 2);
        }
      }

      if (left && !right) {
        player.vx -= accel * dt;
        facing = -1;
      } else if (right && !left) {
        player.vx += accel * dt;
        facing = 1;
      } else {
        if (player.onGround) {
          if (Math.abs(player.vx) < frictionGround * dt) player.vx = 0;
          else player.vx -= Math.sign(player.vx) * frictionGround * dt;
        }
      }
      player.vx = Math.max(-maxSp, Math.min(maxSp, player.vx));

      if (jumpBufferTimer > 0) {
        jumpBufferTimer -= dt;
        if (jumpBufferTimer < 0) jumpBufferTimer = 0;
      }

      player.vy += gravity * dt;
      const wasOnGround = player.onGround;
      resolveCollisions(player, dt);
      if (player.onGround) {
        coyoteTimer = coyoteTime;
      } else {
        coyoteTimer -= dt;
        if (coyoteTimer < 0) coyoteTimer = 0;
      }

      if (jumpBufferTimer > 0 && jumpsLeft > 0) {
        const canGroundJump = player.onGround || coyoteTimer > 0;
        const canExtraJump = isMonks ? !player.onGround : false;
        const canDouble = hasDoubleJump && doubleJumpTimer > 0 && !canGroundJump && jumpsLeft > 0;
        if (canGroundJump || canExtraJump || canDouble) {
          player.vy = -jSp;
          player.onGround = false;
          if (!isMonks) jumpsLeft -= 1;
          jumpBufferTimer = 0;
          coyoteTimer = 0;
          if (isGolem) spawnParticles('land', player.x + player.w * 0.5, player.y + player.h, 34);
          else spawnParticles('jump', player.x + player.w * 0.5, player.y + player.h, 12);
          if (isGolem) sfxGolemCrash();
          else sfxJump();
          if (!isMonks) {
            shakeTime = 0.07;
            shakeStrength = Math.max(shakeStrength, 1.5);
          }
        }
      }

      if (player.onGround && !wasOnGround) {
        jumpsLeft = isMonks ? 999 : (hasDoubleJump ? 2 : 1);
        if (!isMonks) spawnParticles('land', player.x + player.w * 0.5, player.y + player.h, 14);
        if (!isMonks && !isNinja) sfxLand();
        if (!isMonks) {
          shakeTime = 0.10;
          shakeStrength = Math.max(shakeStrength, 3.5);
        }
      }

      if (menuView === 'shop') {
        for (const hz of hazards) {
          if (rectsOverlap(player, hz)) {
            if (isGolem) {
              if (golemInvuln > 0) continue;
              if (golemLives > 0) {
                golemLives -= 1;
                golemInvuln = 0.6;
                golemHitFlash = 0.25;
                sfxGolemCrash();
                spawnParticles('land', player.x + player.w * 0.5, player.y + player.h * 0.5, 46);
                shakeTime = 0.14;
                shakeStrength = Math.max(shakeStrength, 7);
                player.y = hz.y - player.h - 2;
                player.vy = -260;
                player.vx = -Math.sign((player.vx || 0) || facing) * 220;
              } else {
                triggerDeath();
              }
            } else {
              triggerDeath();
            }
          }
        }
        for (let i = powerups.length - 1; i >= 0; i--) {
          const pu = powerups[i];
          if (rectsOverlap(player, pu)) {
            if (pu.type === 'double') {
              if (!isMonks) {
                hasDoubleJump = true;
                doubleJumpTimer = 15;
                jumpsLeft = player.onGround ? 2 : Math.max(1, jumpsLeft);
              }
              doubleJumpAura = Math.max(doubleJumpAura, 15);
              spawnParticles('power', pu.x + pu.w * 0.5, pu.y + pu.h * 0.5, 30);
              shakeTime = 0.10;
              shakeStrength = Math.max(shakeStrength, 3);
            }
            powerups.splice(i, 1);
          }
        }
      }

      if (isNinja && teleportEdge && teleportCooldown <= 0 && !evoDashActive) {
        teleportFrom.x = player.x;
        teleportFrom.y = player.y;
        const dist = 480;
        player.x += facing * dist;
        player.vx = 0;
        for (const s of platforms) {
          if (!rectsOverlap(player, s)) continue;
          if (facing > 0) player.x = s.x - player.w - 1;
          else player.x = s.x + s.w + 1;
        }
        teleportTo.x = player.x;
        teleportTo.y = player.y;
        teleportCooldown = isEvo ? 15 : 20;
        teleportFxTime = teleportFxDuration;
        sfxTeleport();
        spawnParticles('power', player.x + player.w * 0.5, player.y + player.h * 0.5, 18);
        shakeTime = 0.10;
        shakeStrength = Math.max(shakeStrength, 4);

        if (isEvo) {
          evoTeleportUses += 1;
          if (evoTeleportUses >= 3 && !evoBurstReady && evoBurstWait <= 0) evoBurstWait = 10;
        }
      }

      // Selection is handled via click/tap (not by walking into UI elements)

      camera.x = Math.max(0, player.x - canvas.width * 0.45);
      camera.y = 0;
    }

    function update(dt) {
      t += dt;
      if (gameOver) {
        updateDeath(dt);
        updateParticles(dt);
        if (missionToastTime > 0) {
          missionToastTime = Math.max(0, missionToastTime - dt);
          if (missionToastTime <= 0) missionToast = '';
        }
        checkMissions();
        if (screen === 'menu' && menuView === 'shop' && deathTimer >= deathDuration) {
          gameOver = false;
          deathTimer = 0;
          deathPieces = [];
          shopRespawn();
        }
        return;
      }
      if (screen !== 'play') {
        updateHub(dt);
        updateParticles(dt);
        return;
      }

      if (shopMessageTime > 0) {
        shopMessageTime = Math.max(0, shopMessageTime - dt);
        if (shopMessageTime <= 0) shopMessage = '';
      }
      if (coinToastTime > 0) {
        coinToastTime = Math.max(0, coinToastTime - dt);
        if (coinToastTime <= 0) coinToast = '';
      }
      if (missionToastTime > 0) {
        missionToastTime = Math.max(0, missionToastTime - dt);
        if (missionToastTime <= 0) missionToast = '';
      }

      runSurvivalTime += dt;
      // Input: left/right
      const left = keys.has('a') || keys.has('arrowleft');
      const right = keys.has('d') || keys.has('arrowright');
      const jumpPressed = keys.has(' ') || keys.has('arrowup') || keys.has('w');
      const jumpEdge = jumpPressed && !jumpHeld; // only on press, not hold
      jumpHeld = jumpPressed;
      if (jumpEdge) {
        jumpBufferTimer = jumpBufferTime;
      }

      const skin = getSkin(selectedSkinId);
      const isEvo = skin.id === 'evo-ninja';
      const isNinja = skin.id === 'ninja' || isEvo;
      const isMonks = skin.id === 'monks';
      const isGolem = skin.id === 'iron-golem';

      if (teleportCooldown > 0) teleportCooldown = Math.max(0, teleportCooldown - dt);
      if (teleportFxTime > 0) teleportFxTime = Math.max(0, teleportFxTime - dt);
      if (golemInvuln > 0) golemInvuln = Math.max(0, golemInvuln - dt);
      if (golemHitFlash > 0) golemHitFlash = Math.max(0, golemHitFlash - dt);
      if (doubleJumpAura > 0) doubleJumpAura = Math.max(0, doubleJumpAura - dt);

      if (isEvo) {
        if (evoBurstWait > 0) {
          evoBurstWait = Math.max(0, evoBurstWait - dt);
          if (evoBurstWait <= 0 && evoTeleportUses >= 3) evoBurstReady = true;
        }
      } else {
        evoTargeting = false;
        evoDashActive = false;
        evoBurstReady = false;
        evoBurstWait = 0;
        evoTeleportUses = 0;
      }

      if (isMonks) {
        hasDoubleJump = false;
        doubleJumpTimer = 0;
        if (player.onGround) jumpsLeft = 999;
        else jumpsLeft = Math.max(jumpsLeft, 2);
      }

      const teleportPressed = keys.has('e');
      const teleportEdge = teleportPressed && !teleportHeld;
      teleportHeld = teleportPressed;

      const gPressed = keys.has('g');
      const gEdge = gPressed && !gHeld;
      gHeld = gPressed;
      if (isEvo && gEdge && evoBurstReady && !evoTargeting && !evoDashActive && !gameOver) {
        evoTargeting = true;
        canvas.style.cursor = 'crosshair';
      }

      if (evoDashActive) {
        evoDashTimer -= dt;
        while (evoDashActive && evoDashTimer <= 0) {
          const fromX = player.x;
          const fromY = player.y;
          const pt = evoDashPts[evoDashStep];
          teleportFrom.x = fromX;
          teleportFrom.y = fromY;
          player.x = pt.x;
          player.y = pt.y;
          player.vx = 0;
          player.vy = 0;
          for (let k = 0; k < 6; k++) {
            let minY = Infinity;
            for (const s of platforms) {
              if (rectsOverlap(player, s)) minY = Math.min(minY, s.y - player.h - 2);
            }
            if (minY !== Infinity) player.y = minY;
            else break;
          }
          teleportTo.x = player.x;
          teleportTo.y = player.y;
          teleportFxTime = teleportFxDuration;
          sfxTeleport();
          spawnParticles('power', player.x + player.w * 0.5, player.y + player.h * 0.5, 18);
          shakeTime = 0.10;
          shakeStrength = Math.max(shakeStrength, 4);
          evoDashStep += 1;
          evoDashTimer = 0.09;
          if (evoDashStep >= 3) {
            evoDashActive = false;
            break;
          }
        }
      }

      let accel = moveAccel;
      let maxSp = maxSpeedX;
      let jSp = jumpSpeed;
      if (isNinja) { accel *= 1.3; maxSp *= 1.35; jSp *= 1.25; }

      // Horizontal accel
      if (left && !right) {
        player.vx -= accel * dt;
        facing = -1;
      } else if (right && !left) {
        player.vx += accel * dt;
        facing = 1;
      } else {
        // apply ground friction when no input
        if (player.onGround) {
          if (Math.abs(player.vx) < frictionGround * dt) player.vx = 0;
          else player.vx -= Math.sign(player.vx) * frictionGround * dt;
        }
      }
      // Clamp speed
      player.vx = Math.max(-maxSp, Math.min(maxSp, player.vx));

      // Timers
      if (doubleJumpTimer > 0) {
        doubleJumpTimer -= dt;
        if (doubleJumpTimer <= 0) { doubleJumpTimer = 0; hasDoubleJump = false; if (jumpsLeft > 1) jumpsLeft = 1; }
      }

      if (jumpBufferTimer > 0) {
        jumpBufferTimer -= dt;
        if (jumpBufferTimer < 0) jumpBufferTimer = 0;
      }

      // Gravity
      player.vy += gravity * dt;

      updateDynamicPlatforms();

      // Integrate and collide
      const wasOnGround = player.onGround;
      resolveCollisions(player, dt);
      if (player.onGround) {
        coyoteTimer = coyoteTime;
      } else {
        coyoteTimer -= dt;
        if (coyoteTimer < 0) coyoteTimer = 0;
      }

      if (jumpBufferTimer > 0 && jumpsLeft > 0) {
        const canGroundJump = player.onGround || coyoteTimer > 0;
        const canExtraJump = isMonks ? !player.onGround : false;
        const canDouble = hasDoubleJump && doubleJumpTimer > 0 && !canGroundJump && jumpsLeft > 0;
        if (canGroundJump || canExtraJump || canDouble) {
          player.vy = -jSp;
          player.onGround = false;
          if (!isMonks) jumpsLeft -= 1;
          jumpBufferTimer = 0;
          coyoteTimer = 0;
          if (isGolem) spawnParticles('land', player.x + player.w * 0.5, player.y + player.h, 44);
          else spawnParticles('jump', player.x + player.w * 0.5, player.y + player.h, 14);
          if (isGolem) sfxGolemCrash();
          else sfxJump();
          if (!isMonks) {
            shakeTime = 0.07;
            shakeStrength = Math.max(shakeStrength, 1.5);
          }
        }
      }

      if (player.onGround && !wasOnGround) {
        jumpsLeft = isMonks ? 999 : (hasDoubleJump ? 2 : 1);
        if (isGolem) spawnParticles('land', player.x + player.w * 0.5, player.y + player.h, 42);
        else if (!isMonks) spawnParticles('land', player.x + player.w * 0.5, player.y + player.h, 18);
        if (!isMonks && !isNinja) sfxLand();
        if (!isMonks) {
          shakeTime = 0.10;
          shakeStrength = Math.max(shakeStrength, 3.5);
        }
      }

      if (player.onGround) {
        const gp = getGroundPlatform();
        if (gp && gp.type === 'bounce') {
          player.vy = -jumpSpeed * 1.35;
          player.onGround = false;
          coyoteTimer = 0;
          jumpBufferTimer = 0;
          spawnParticles('power', player.x + player.w * 0.5, player.y + player.h, 22);
          sfxBounce();
          shakeTime = 0.10;
          shakeStrength = Math.max(shakeStrength, 4.5);
        }
      }

      if (isNinja && teleportEdge && teleportCooldown <= 0 && !evoDashActive) {
        teleportFrom.x = player.x;
        teleportFrom.y = player.y;
        const dist = 480;
        player.x += facing * dist;
        player.vx = 0;
        for (const s of platforms) {
          if (!rectsOverlap(player, s)) continue;
          if (facing > 0) player.x = s.x - player.w - 1;
          else player.x = s.x + s.w + 1;
        }
        teleportTo.x = player.x;
        teleportTo.y = player.y;
        teleportCooldown = isEvo ? 15 : 20;
        teleportFxTime = teleportFxDuration;
        runTeleports += 1;
        sfxTeleport();
        spawnParticles('power', player.x + player.w * 0.5, player.y + player.h * 0.5, 22);
        if (isEvo) spawnParticles('smoke', player.x + player.w * 0.5, player.y + player.h * 0.6, 18);
        shakeTime = 0.12;
        shakeStrength = Math.max(shakeStrength, 5);

        if (isEvo) {
          evoTeleportUses += 1;
          if (evoTeleportUses >= 3 && !evoBurstReady && evoBurstWait <= 0) evoBurstWait = 10;
        }
      }

      // Hazards
      for (const hz of hazards) {
        if (rectsOverlap(player, hz)) {
          if (isGolem && golemInvuln <= 0) {
            if (golemLives > 0) {
              golemLives -= 1;
              golemInvuln = 0.6;
              golemHitFlash = 0.25;
              sfxGolemCrash();
              spawnParticles('land', player.x + player.w * 0.5, player.y + player.h * 0.5, 52);
              shakeTime = 0.12;
              shakeStrength = Math.max(shakeStrength, 7);
            } else {
              spawnParticles('power', player.x + player.w * 0.5, player.y + player.h * 0.5, 42);
              shakeTime = 0.22;
              shakeStrength = Math.max(shakeStrength, 8);
              triggerDeath();
            }
          } else if (!isGolem) {
            triggerDeath();
          }
        }
      }
      // Powerups
      for (let i = powerups.length - 1; i >= 0; i--) {
        const pu = powerups[i];
        if (rectsOverlap(player, pu)) {
          if (pu.type === 'double') {
            runPowerups += 1;
            if (!isMonks) {
              hasDoubleJump = true;
              doubleJumpTimer = 15; // seconds
              jumpsLeft = player.onGround ? 2 : Math.max(1, jumpsLeft);
            }
            doubleJumpAura = Math.max(doubleJumpAura, 15);
            spawnParticles('power', pu.x + pu.w * 0.5, pu.y + pu.h * 0.5, 30);
            shakeTime = 0.12;
            shakeStrength = Math.max(shakeStrength, 4);
          }
          powerups.splice(i, 1);
        }
      }
      // Bounds fall
      if (player.y > canvas.height + 200) { triggerDeath(); }

      // Update max distance and checkpoints
      if (player.x > maxReachedX) maxReachedX = player.x;
      const distNow = Math.floor(maxReachedX);
      if (distNow > bestDistanceAll) {
        bestDistanceAll = distNow;
        try {
          localStorage.setItem(BEST_DISTANCE_ALL_KEY, String(bestDistanceAll));
        } catch (e) {}
      }
      if (!noCheckpointsMode) {
        for (const cp of checkpoints) {
          if (rectsOverlap(player, cp)) {
            if (lastCheckpoint.x !== cp.x) {
              addCoins(10);
              sfxCoin();
              coinToast = '+10 COINS';
              coinToastTime = 0.9;
              runCheckpoints += 1;
            }
            // Place checkpoint spawn on top of nearest platform below this cp
            let spawnY = canvas.height - 40 - player.h;
            for (const s of platforms) {
              if (s.x <= cp.x && cp.x <= s.x + s.w) {
                spawnY = Math.min(spawnY, s.y - player.h);
              }
            }
            lastCheckpoint.x = cp.x;
            lastCheckpoint.y = spawnY;
            checkpointFlashTime = 1.2;
          }
        }
      }

      if (noCheckpointsMode) {
        if (!bestDistanceBeaten && distNow > bestDistanceStart && distNow >= 1) {
          bestDistanceBeaten = true;
          bestDistAnimTime = bestDistAnimDuration;
          bestDistance = Math.max(bestDistance, distNow);
          try {
            localStorage.setItem(BEST_DISTANCE_KEY, String(bestDistance));
          } catch (e) {}
        }
        if (bestDistanceBeaten && distNow > bestDistance) {
          bestDistance = distNow;
          try {
            localStorage.setItem(BEST_DISTANCE_KEY, String(bestDistance));
          } catch (e) {}
        }
      }

      bestDistAnimTime = Math.max(0, bestDistAnimTime - dt);

      // Generate world ahead and move camera
      ensureWorldAhead();
      // Camera follows player
      camera.x = player.x - canvas.width * 0.4;
      camera.y = Math.max(0, player.y - canvas.height * 0.5);
      if (camera.x < 0) camera.x = 0;

      updateParticles(dt);

      trail.push({ x: player.x, y: player.y, t });
      while (trail.length > 14) trail.shift();

      checkMissions();
    }

    function draw() {
      // Clear to sky gradient (already via CSS background). Draw world elements.
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      if (!shakeEnabled) {
        shakeTime = 0;
        shakeStrength = 0;
      }
      if (shakeTime > 0) {
        const dtShake = Math.min(shakeTime, 1/60);
        shakeTime -= dtShake;
        if (shakeTime <= 0) { shakeTime = 0; shakeStrength = 0; }
      }
      const sx = shakeStrength ? (Math.sin(t * 60) * shakeStrength) : 0;
      const sy = shakeStrength ? (Math.cos(t * 73) * shakeStrength) : 0;

      ctx.save();
      ctx.translate(sx, sy);

      // Helper to draw rect in world coords
      function drawRect(x, y, w, h, fill, stroke) {
        ctx.fillStyle = fill;
        ctx.fillRect(worldToScreenX(x), worldToScreenY(y), w, h);
        if (stroke) {
          ctx.strokeStyle = stroke;
          ctx.strokeRect(worldToScreenX(x), worldToScreenY(y), w, h);
        }
      }

      function drawPanel(x, y, w, h) {
        ctx.save();
        ctx.globalAlpha = 0.85;
        roundRectPath(x, y, w, h, 12);
        ctx.fillStyle = 'rgba(255,255,255,0.72)';
        ctx.fill();
        ctx.globalAlpha = 0.35;
        ctx.lineWidth = 1;
        ctx.strokeStyle = 'rgba(0,0,0,0.35)';
        ctx.stroke();
        ctx.restore();
      }

      function drawParallax() {
        const w = canvas.width;
        const h = canvas.height;
        const ox = -(camera.x * 0.18) % 120;
        const oy = -(camera.y * 0.18) % 72;
        ctx.save();
        ctx.globalAlpha = 0.22;
        ctx.fillStyle = 'rgba(255,255,255,0.03)';
        ctx.strokeStyle = 'rgba(0,0,0,0.55)';
        ctx.lineWidth = 1;
        const brickW = 120;
        const brickH = 72;
        for (let y = -brickH; y < h + brickH; y += brickH) {
          const row = Math.floor((y + oy) / brickH);
          const rowShift = (row % 2) * (brickW / 2);
          for (let x = -brickW; x < w + brickW; x += brickW) {
            const bx = Math.floor(x + ox + rowShift);
            const by = Math.floor(y + oy);
            ctx.fillRect(bx + 1, by + 1, brickW - 2, brickH - 2);
            ctx.strokeRect(bx + 0.5, by + 0.5, brickW, brickH);
          }
        }
        ctx.globalAlpha = 0.65;
        const glow = ctx.createRadialGradient(w * 0.18, h * 0.92, 20, w * 0.18, h * 0.92, h * 0.75);
        glow.addColorStop(0, 'rgba(255,120,0,0.25)');
        glow.addColorStop(0.4, 'rgba(255,40,0,0.14)');
        glow.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = glow;
        ctx.fillRect(0, 0, w, h);
        ctx.restore();
      }

      function drawVignette() {
        const w = canvas.width;
        const h = canvas.height;
        ctx.save();
        const g = ctx.createRadialGradient(w * 0.5, h * 0.5, Math.min(w, h) * 0.2, w * 0.5, h * 0.5, Math.max(w, h) * 0.75);
        g.addColorStop(0, 'rgba(0,0,0,0)');
        g.addColorStop(1, 'rgba(0,0,0,0.42)');
        ctx.fillStyle = g;
        ctx.fillRect(0, 0, w, h);
        ctx.restore();
      }

      function drawPlatform(s) {
        const x = worldToScreenX(s.x);
        const y = worldToScreenY(s.y);
        const isGround = s.type === 'ground';
        const isMoving = s.type === 'moving';
        const isBounce = s.type === 'bounce';
        const base = isGround ? '#4b5563' : (isBounce ? '#0ea5e9' : (isMoving ? '#7c3aed' : '#6b7280'));
        const top = isGround ? '#9ca3af' : (isBounce ? '#7dd3fc' : (isMoving ? '#c4b5fd' : '#d1d5db'));
        const bottom = isGround ? '#111827' : (isBounce ? '#075985' : (isMoving ? '#2e1065' : '#1f2937'));
        ctx.save();
        ctx.shadowColor = 'rgba(0,0,0,0.35)';
        ctx.shadowBlur = 12;
        ctx.shadowOffsetY = 6;
        roundRectPath(x, y, s.w, s.h, 6);
        const g = ctx.createLinearGradient(0, y, 0, y + s.h);
        g.addColorStop(0, top);
        g.addColorStop(0.38, base);
        g.addColorStop(1, bottom);
        ctx.fillStyle = g;
        ctx.fill();
        ctx.shadowBlur = 0;
        ctx.globalAlpha = 0.35;
        ctx.strokeStyle = 'rgba(255,255,255,0.25)';
        ctx.lineWidth = 1;
        ctx.stroke();
        ctx.restore();
      }

      function drawHazard(hz) {
        const x = worldToScreenX(hz.x);
        const y = worldToScreenY(hz.y);
        const spikes = Math.max(3, Math.floor(hz.w / 14));
        const step = hz.w / spikes;
        ctx.save();
        ctx.shadowColor = 'rgba(239,68,68,0.55)';
        ctx.shadowBlur = 14;
        const g = ctx.createLinearGradient(0, y, 0, y + hz.h);
        g.addColorStop(0, '#fecaca');
        g.addColorStop(0.35, '#ef4444');
        g.addColorStop(1, '#7f1d1d');
        ctx.fillStyle = g;
        ctx.beginPath();
        ctx.moveTo(x, y + hz.h);
        for (let i = 0; i < spikes; i++) {
          const x0 = x + i * step;
          const x1 = x0 + step;
          const xm = (x0 + x1) / 2;
          ctx.lineTo(x0, y + hz.h);
          ctx.lineTo(xm, y);
          ctx.lineTo(x1, y + hz.h);
        }
        ctx.closePath();
        ctx.fill();
        ctx.shadowBlur = 0;
        ctx.globalAlpha = 0.35;
        ctx.strokeStyle = 'rgba(0,0,0,0.35)';
        ctx.lineWidth = 1;
        ctx.stroke();
        ctx.restore();
      }

      function drawPowerup(pu) {
        const cx = pu.x - camera.x, cy = pu.y - camera.y;
        const pulse = 0.5 + 0.5 * Math.sin(t * 5);
        ctx.save();
        ctx.translate(Math.floor(cx + pu.w/2), Math.floor(cy + pu.h/2));
        ctx.rotate(Math.PI/4);
        ctx.shadowColor = 'rgba(6,182,212,0.75)';
        ctx.shadowBlur = 16;
        ctx.fillStyle = `rgba(6,182,212,${lerp(0.65, 0.95, pulse)})`;
        ctx.fillRect(-pu.w/2, -pu.h/2, pu.w, pu.h);
        ctx.shadowBlur = 0;
        ctx.globalAlpha = 0.35;
        ctx.strokeStyle = 'rgba(255,255,255,0.5)';
        ctx.lineWidth = 1;
        ctx.strokeRect(-pu.w/2, -pu.h/2, pu.w, pu.h);
        ctx.restore();
      }

      function drawCheckpoint(cp) {
        const x = worldToScreenX(cp.x);
        const y = worldToScreenY(cp.y);
        ctx.save();
        const pulse = 0.45 + 0.55 * Math.sin(t * 3.3);
        ctx.shadowColor = 'rgba(34,197,94,0.55)';
        ctx.shadowBlur = 14;
        const g = ctx.createLinearGradient(0, y, 0, y + cp.h);
        g.addColorStop(0, `rgba(34,197,94,${lerp(0.55, 0.95, pulse)})`);
        g.addColorStop(1, 'rgba(21,128,61,0.95)');
        roundRectPath(x, y, cp.w, cp.h, 6);
        ctx.fillStyle = g;
        ctx.fill();
        ctx.shadowBlur = 0;
        ctx.globalAlpha = 0.3;
        ctx.strokeStyle = 'rgba(255,255,255,0.5)';
        ctx.lineWidth = 1;
        ctx.stroke();
        ctx.restore();
      }

      function drawPlayer() {
        if (gameOver && deathPieces.length) {
          const a = clamp(1 - (deathTimer / deathDuration), 0, 1);
          for (const p of deathPieces) {
            const x = worldToScreenX(p.x);
            const y = worldToScreenY(p.y);
            ctx.save();
            ctx.translate(Math.floor(x + p.w * 0.5), Math.floor(y + p.h * 0.5));
            ctx.rotate(p.rot);
            ctx.globalAlpha = a;
            ctx.fillStyle = '#111';
            ctx.shadowColor = 'rgba(0,0,0,0.55)';
            ctx.shadowBlur = 10;
            ctx.fillRect(-p.w * 0.5, -p.h * 0.5, p.w, p.h);
            ctx.shadowBlur = 0;
            ctx.globalAlpha = a * 0.25;
            ctx.strokeStyle = 'rgba(255,255,255,0.14)';
            ctx.lineWidth = 1;
            ctx.strokeRect(-p.w * 0.5, -p.h * 0.5, p.w, p.h);
            ctx.restore();
          }
          return;
        }

        const skin = getSkin(selectedSkinId);
        const isEvo = skin.id === 'evo-ninja';
        const isNinja = skin.id === 'ninja' || isEvo;
        const isMonks = skin.id === 'monks';
        const isGolem = skin.id === 'iron-golem';
        const body = skin.body || '#111';
        const accent = skin.accent || '#3b82f6';

        if (isNinja && teleportFxTime > 0) {
          const elapsed = teleportFxDuration - teleportFxTime;
          const half = teleportFxDuration * 0.5;
          const from = { x: teleportFrom.x + player.w * 0.5, y: teleportFrom.y + player.h * 0.5 };
          const to = { x: teleportTo.x + player.w * 0.5, y: teleportTo.y + player.h * 0.5 };
          const at = elapsed < half ? from : to;
          const p = elapsed < half ? (elapsed / half) : ((elapsed - half) / half);
          const r = elapsed < half ? lerp(10, 2, p) : lerp(2, 11, p);
          const x = worldToScreenX(at.x);
          const y = worldToScreenY(at.y);
          ctx.save();
          const fxA = elapsed < half ? lerp(1, 0.1, p) : lerp(0.1, 1, p);
          const fxFromX = worldToScreenX(from.x);
          const fxFromY = worldToScreenY(from.y);
          const fxToX = worldToScreenX(to.x);
          const fxToY = worldToScreenY(to.y);
          ctx.globalAlpha = fxA * 0.7;
          ctx.strokeStyle = isEvo ? 'rgba(168,85,247,0.6)' : 'rgba(239,68,68,0.55)';
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.moveTo(fxFromX, fxFromY);
          ctx.lineTo(fxToX, fxToY);
          ctx.stroke();
          ctx.globalAlpha = elapsed < half ? lerp(1, 0.1, p) : lerp(0.1, 1, p);
          ctx.fillStyle = body;
          ctx.shadowColor = isEvo ? 'rgba(168,85,247,0.75)' : 'rgba(239,68,68,0.55)';
          ctx.shadowBlur = isEvo ? 26 : 18;
          ctx.beginPath();
          ctx.arc(x, y, r, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
          return;
        }

        for (let i = 0; i < trail.length; i++) {
          const p = trail[i];
          const a = i / trail.length;
          const x = worldToScreenX(p.x);
          const y = worldToScreenY(p.y);
          ctx.save();
          if (isNinja) {
            const cx = x + player.w * 0.5;
            const cy = y + player.h * 0.55;
            const rr = player.w * 0.95;
            const tg = ctx.createRadialGradient(cx, cy, player.w * 0.15, cx, cy, rr);
            tg.addColorStop(0, isEvo ? `rgba(0,0,0,${a * 0.38})` : `rgba(0,0,0,${a * 0.22})`);
            tg.addColorStop(0.55, isEvo ? `rgba(168,85,247,${a * 0.12})` : `rgba(0,0,0,${a * 0.08})`);
            tg.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.globalAlpha = 1;
            ctx.fillStyle = tg;
            ctx.fillRect(cx - rr, cy - rr, rr * 2, rr * 2);
          } else {
            ctx.globalAlpha = a * 0.18;
            roundRectPath(x, y, player.w, player.h, 10);
            ctx.fillStyle = rgba(body, 1);
            ctx.fill();
          }
          ctx.restore();
        }

        const x = worldToScreenX(player.x);
        const y = worldToScreenY(player.y);

        if (doubleJumpAura > 0) {
          const a = Math.min(1, doubleJumpAura / 15);
          ctx.save();
          ctx.globalAlpha = 0.35 * a;
          ctx.shadowColor = 'rgba(59,130,246,0.9)';
          ctx.shadowBlur = 22;
          ctx.fillStyle = 'rgba(59,130,246,0.25)';
          roundRectPath(x - 6, y - 6, player.w + 12, player.h + 12, 14);
          ctx.fill();
          ctx.restore();
        }

        if (isNinja) {
          const cx = x + player.w * 0.5;
          const cy = y + player.h * 0.58;
          const rr = Math.max(player.w, player.h) * (isEvo ? 1.05 : 0.9);
          ctx.save();
          ctx.globalAlpha = 1;
          const sg = ctx.createRadialGradient(cx, cy, player.w * 0.12, cx, cy, rr);
          sg.addColorStop(0, isEvo ? 'rgba(0,0,0,0.95)' : 'rgba(0,0,0,0.85)');
          sg.addColorStop(0.35, isEvo ? 'rgba(168,85,247,0.16)' : 'rgba(0,0,0,0.35)');
          sg.addColorStop(0.6, isEvo ? 'rgba(0,0,0,0.45)' : 'rgba(0,0,0,0.35)');
          sg.addColorStop(1, 'rgba(0,0,0,0)');
          ctx.fillStyle = sg;
          ctx.fillRect(cx - rr, cy - rr, rr * 2, rr * 2);

          if (isEvo) {
            ctx.globalAlpha = 0.22;
            ctx.shadowColor = 'rgba(168,85,247,0.55)';
            ctx.shadowBlur = 18;
            roundRectPath(x + 2, y + 2, player.w - 4, player.h - 4, 10);
            ctx.fillStyle = rgba(body, 1);
            ctx.fill();
            ctx.shadowBlur = 0;
            ctx.globalAlpha = 0.14;
            roundRectPath(x + 8, y + 14, player.w - 16, 10, 6);
            ctx.fillStyle = 'rgba(168,85,247,0.9)';
            ctx.fill();
            ctx.globalAlpha = 1;
          }

          const eyeY = y + player.h * 0.36;
          const eyeDx = 9;
          ctx.fillStyle = isEvo ? 'rgba(168,85,247,0.98)' : 'rgba(239,68,68,0.98)';
          ctx.shadowColor = isEvo ? 'rgba(168,85,247,0.95)' : 'rgba(239,68,68,0.9)';
          ctx.shadowBlur = isEvo ? 20 : 16;
          ctx.beginPath();
          ctx.arc(cx - eyeDx, eyeY, 2.6, 0, Math.PI * 2);
          ctx.arc(cx + eyeDx, eyeY, 2.6, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
          return;
        }

        ctx.save();
        ctx.shadowColor = 'rgba(0,0,0,0.55)';
        ctx.shadowBlur = 14;
        ctx.shadowOffsetY = 6;
        roundRectPath(x, y, player.w, player.h, 10);
        const g = ctx.createLinearGradient(0, y, 0, y + player.h);
        g.addColorStop(0, rgba(body, 1));
        g.addColorStop(1, rgba(body, 0.55));
        ctx.fillStyle = g;
        ctx.fill();
        ctx.shadowBlur = 0;
        ctx.globalAlpha = 0.22;
        const hg = ctx.createRadialGradient(x + player.w * 0.32, y + player.h * 0.22, 2, x + player.w * 0.32, y + player.h * 0.22, player.w * 0.95);
        hg.addColorStop(0, 'rgba(255,255,255,0.55)');
        hg.addColorStop(0.35, 'rgba(255,255,255,0.12)');
        hg.addColorStop(1, 'rgba(255,255,255,0)');
        roundRectPath(x, y, player.w, player.h, 10);
        ctx.fillStyle = hg;
        ctx.fill();
        ctx.shadowBlur = 0;
        ctx.globalAlpha = 0.35;
        ctx.strokeStyle = 'rgba(255,255,255,0.12)';
        ctx.lineWidth = 1;
        ctx.stroke();
        ctx.globalAlpha = 0.9;
        if (isMonks) {
          roundRectPath(x + 8, y + 12, player.w - 16, 10, 6);
          const vg = ctx.createLinearGradient(x, 0, x + player.w, 0);
          vg.addColorStop(0, rgba(accent, 0.85));
          vg.addColorStop(1, 'rgba(255,255,255,0.65)');
          ctx.fillStyle = vg;
          ctx.fill();
        } else {
          const visorH = 10;
          roundRectPath(x + 8, y + 12, player.w - 16, visorH, 6);
          const vg = ctx.createLinearGradient(x, 0, x + player.w, 0);
          vg.addColorStop(0, rgba(accent, 0.8));
          vg.addColorStop(1, rgba(accent, 0.45));
          ctx.fillStyle = vg;
          ctx.fill();
        }

        if (isGolem) {
          const cracks = clamp(4 - golemLives, 0, 4);
          if (cracks > 0) {
            ctx.save();
            ctx.globalAlpha = lerp(0.25, 0.7, cracks / 4) + (golemHitFlash > 0 ? 0.25 : 0);
            ctx.strokeStyle = 'rgba(0,0,0,0.6)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(x + 6, y + 10);
            ctx.lineTo(x + player.w - 8, y + 18);
            if (cracks >= 2) {
              ctx.moveTo(x + 10, y + player.h - 10);
              ctx.lineTo(x + player.w - 12, y + 26);
            }
            if (cracks >= 3) {
              ctx.moveTo(x + player.w * 0.5, y + 8);
              ctx.lineTo(x + player.w * 0.35, y + player.h - 6);
            }
            if (cracks >= 4) {
              ctx.moveTo(x + player.w * 0.7, y + 10);
              ctx.lineTo(x + player.w * 0.55, y + player.h - 6);
            }
            ctx.stroke();
            ctx.restore();
          }
        }
        ctx.restore();
      }

      function drawParticles() {
        for (const p of particles) {
          const a = clamp(p.life / p.ttl, 0, 1);
          const x = worldToScreenX(p.x);
          const y = worldToScreenY(p.y);
          ctx.save();
          ctx.globalAlpha = a;
          ctx.fillStyle = rgba(p.color, 0.95);
          ctx.shadowColor = rgba(p.color, 0.65);
          ctx.shadowBlur = 10;
          ctx.beginPath();
          ctx.arc(x, y, p.size * lerp(0.6, 1.0, a), 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
        }
      }

      drawParallax();

      // Draw platforms
      for (const s of platforms) {
        drawPlatform(s);
      }
      // Draw hazards (spikes as red bars)
      for (const hz of hazards) {
        drawHazard(hz);
      }
      // Draw powerups (double-jump = cyan diamond)
      for (const pu of powerups) {
        drawPowerup(pu);
      }
      // Draw checkpoints
      for (const cp of checkpoints) {
        drawCheckpoint(cp);
      }

      // Draw player
      drawPlayer();

      drawParticles();

      const skin = getSkin(selectedSkinId);

      if (screen === 'menu') {
        for (const z of menuZones) {
          const zx = worldToScreenX(z.x);
          const zy = worldToScreenY(z.y);
          const over = pointerActive && pointInRect(pointerWorldX, pointerWorldY, z);
          ctx.save();
          ctx.globalAlpha = over ? 0.95 : 0.78;
          roundRectPath(zx, zy, z.w, z.h, 14);
          ctx.fillStyle = over ? 'rgba(255,255,255,0.82)' : 'rgba(255,255,255,0.65)';
          ctx.fill();
          ctx.globalAlpha = 0.35;
          ctx.lineWidth = 1;
          ctx.strokeStyle = 'rgba(0,0,0,0.35)';
          ctx.stroke();
          ctx.globalAlpha = 1;
          ctx.fillStyle = '#111';
          ctx.textAlign = 'center';
          ctx.font = 'bold 16px sans-serif';
          const parts = String(z.label).split('\n');
          for (let i = 0; i < parts.length; i++) {
            ctx.fillText(parts[i], zx + z.w * 0.5, zy + 28 + i * 18);
          }
          ctx.restore();
        }

        if (menuView === 'shop') {
          for (const st of shopStands) {
            const s = getSkin(st.skinId);
            const unlocked = isSkinUnlocked(s.id);
            const over = pointerActive && pointInRect(pointerWorldX, pointerWorldY, st);
            const sx = worldToScreenX(st.x);
            const sy = worldToScreenY(st.y);
            ctx.save();
            ctx.globalAlpha = over ? 0.95 : 0.8;
            roundRectPath(sx, sy, st.w, st.h, 12);
            ctx.fillStyle = unlocked ? 'rgba(255,255,255,0.28)' : 'rgba(0,0,0,0.25)';
            ctx.fill();
            ctx.globalAlpha = 0.45;
            ctx.strokeStyle = unlocked ? 'rgba(255,255,255,0.35)' : 'rgba(255,255,255,0.18)';
            ctx.lineWidth = 1;
            ctx.stroke();
            ctx.globalAlpha = 1;
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 14px sans-serif';
            ctx.textAlign = 'left';
            ctx.fillText(s.name, sx + 12, sy + 22);
            ctx.textAlign = 'right';
            ctx.fillStyle = unlocked ? 'rgba(34,197,94,0.95)' : 'rgba(251,191,36,0.95)';
            ctx.fillText(unlocked ? 'OWNED' : `${s.price}`, sx + st.w - 12, sy + 22);
            ctx.textAlign = 'left';
            ctx.fillStyle = s.body;
            roundRectPath(sx + 12, sy + 32, 24, 30, 6);
            ctx.fill();
            ctx.fillStyle = s.accent;
            roundRectPath(sx + 18, sy + 42, 12, 8, 4);
            ctx.fill();
            if (selectedSkinId === s.id) {
              ctx.globalAlpha = 0.85;
              ctx.fillStyle = 'rgba(59,130,246,0.9)';
              roundRectPath(sx + st.w - 52, sy + st.h - 24, 40, 16, 6);
              ctx.fill();
              ctx.globalAlpha = 1;
              ctx.fillStyle = '#fff';
              ctx.font = 'bold 11px sans-serif';
              ctx.textAlign = 'center';
              ctx.fillText('ON', sx + st.w - 32, sy + st.h - 12);
            }
            ctx.restore();
          }
        }
      }

      // UI overlays
      const lines = [];
      lines.push(`Coins: ${coins}`);
      lines.push(`Skin: ${skin.name}`);
      if (screen === 'play') {
        lines.push(`Mode: ${modeLabel}`);
        if (challengeId !== 'none') lines.push(`Challenge: ${challengeId.toUpperCase()} #${challengeSeed}`);
        if (!noCheckpointsMode) {
          lines.push('Touch green posts to set checkpoint');
          lines.push('R respawn | Shift+R restart');
        } else {
          lines.push('No checkpoints - one run');
          lines.push('R restart');
        }
        lines.push(`Distance: ${Math.floor(maxReachedX)} px`);
        lines.push(`Score: ${score}`);
        if (noCheckpointsMode) lines.push(`Best Score: ${bestScore} | Best Dist: ${bestDistance}px`);
        if (skin.id === 'ninja' || skin.id === 'evo-ninja') lines.push(`Teleport (E): ${teleportCooldown > 0 ? teleportCooldown.toFixed(0) + 's' : 'READY'}`);
        if (skin.id === 'evo-ninja') {
          const superCd = evoBurstWait > 0 ? `${Math.ceil(evoBurstWait)}s` : (evoBurstReady ? 'READY' : `${Math.min(3, evoTeleportUses)}/3`);
          lines.push(`Super Teleport (G): ${superCd}`);
        }
        if (skin.id === 'iron-golem') lines.push(`Shield: ${Math.max(0, golemLives)}/4`);
        if (hasDoubleJump && skin.id !== 'monks') lines.push(`Double-jump: ON (${Math.ceil(doubleJumpTimer)}s)`);

        if (missions.length) {
          lines.push('Missions:');
          for (const m of missions) {
            const prog = missionProgress(m);
            const showProg = (m.type === 'nodeaths') ? (deathsThisRun === 0 ? `${prog}/${m.target}s` : `FAILED`) : `${prog}/${m.target}`;
            lines.push(`${m.done ? '✓' : '·'} ${m.name}: ${showProg} (+${m.reward})`);
          }
        }
      } else if (screen === 'menu') {
        if (shopMessageTime > 0 && shopMessage) lines.push(shopMessage);
        if (menuView === 'shop' && skin.type === 'power' && skin.desc) {
          const wrapText = (text, maxLen) => {
            const words = String(text).split(/\s+/).filter(Boolean);
            const out = [];
            let line = '';
            for (const w of words) {
              const next = line ? (line + ' ' + w) : w;
              if (next.length > maxLen && line) {
                out.push(line);
                line = w;
              } else {
                line = next;
              }
            }
            if (line) out.push(line);
            return out;
          };
          lines.push('Power:');
          for (const ln of wrapText(skin.desc, 44)) lines.push(ln);
        }
        if (menuView === 'shop') {
          if (skin.id === 'ninja' || skin.id === 'evo-ninja') lines.push(`Teleport (E): ${teleportCooldown > 0 ? teleportCooldown.toFixed(0) + 's' : 'READY'}`);
          if (hasDoubleJump && skin.id !== 'monks') lines.push(`Double-jump: ON (${Math.ceil(doubleJumpTimer)}s)`);
        }
      }

      const panelW = 500;
      const lineH = 20;
      const panelH = 18 + lines.length * lineH;
      drawPanel(12, 12, panelW, panelH);
      ctx.font = '16px sans-serif';
      ctx.fillStyle = '#111';
      let yy = 36;
      for (const s of lines) {
        ctx.fillText(s, 26, yy);
        yy += lineH;
      }

      if (screen === 'play') {
        for (const b of getHudButtons()) {
          const over = pointerActive && pointerScreenX >= b.x && pointerScreenX <= b.x + b.w && pointerScreenY >= b.y && pointerScreenY <= b.y + b.h;
          ctx.save();
          ctx.globalAlpha = over ? 0.95 : 0.78;
          roundRectPath(b.x, b.y, b.w, b.h, 10);
          ctx.fillStyle = over ? 'rgba(255,255,255,0.85)' : 'rgba(255,255,255,0.7)';
          ctx.fill();
          ctx.globalAlpha = 0.35;
          ctx.strokeStyle = 'rgba(0,0,0,0.35)';
          ctx.lineWidth = 1;
          ctx.stroke();
          ctx.globalAlpha = 1;
          ctx.fillStyle = '#111';
          ctx.textAlign = 'center';
          ctx.font = 'bold 12px sans-serif';
          ctx.fillText(b.label, b.x + b.w * 0.5, b.y + 22);
          ctx.restore();
        }
        if (shopMessageTime > 0 && shopMessage) {
          drawPanel(canvas.width - 280, 56, 268, 46);
          ctx.fillStyle = '#111';
          ctx.font = '14px sans-serif';
          ctx.textAlign = 'center';
          ctx.fillText(shopMessage, canvas.width - 146, 84);
          ctx.textAlign = 'left';
        }

        if (isTouchDevice && !evoTargeting && !settingsOpen) {
          const b = getMobileButtons();
          const list = [b.left, b.right, b.super, b.teleport, b.jump];
          for (const it of list) {
            const pressed = keys.has(it.key);
            ctx.save();
            ctx.globalAlpha = pressed ? 0.95 : 0.65;
            roundRectPath(it.x, it.y, it.w, it.h, 14);
            ctx.fillStyle = pressed ? 'rgba(255,255,255,0.85)' : 'rgba(255,255,255,0.7)';
            ctx.fill();
            ctx.globalAlpha = 0.35;
            ctx.strokeStyle = 'rgba(0,0,0,0.35)';
            ctx.lineWidth = 1;
            ctx.stroke();
            ctx.globalAlpha = 1;
            ctx.fillStyle = '#111';
            ctx.textAlign = 'center';
            ctx.font = 'bold 12px sans-serif';
            ctx.fillText(it.label, it.x + it.w * 0.5, it.y + 34);
            ctx.restore();
          }
        }
      }

      function drawPopText(text, timeLeft, duration, y, color) {
        const a = clamp(timeLeft / duration, 0, 1);
        const p = 1 - a;
        const ease = 1 - Math.pow(1 - p, 3);
        const scale = lerp(0.92, 1.14, ease);
        ctx.save();
        ctx.translate(canvas.width / 2, y);
        ctx.scale(scale, scale);
        ctx.globalAlpha = a;
        ctx.textAlign = 'center';
        ctx.font = 'bold 30px sans-serif';
        ctx.shadowColor = 'rgba(0,0,0,0.55)';
        ctx.shadowBlur = 16;
        ctx.fillStyle = color;
        ctx.fillText(text, 0, 0);
        ctx.restore();
      }

      if (!gameOver) {
        if (bestDistAnimTime > 0) drawPopText('NEW BEST DISTANCE!', bestDistAnimTime, bestDistAnimDuration, 164, '#fbbf24');
      }

      if (coinToastTime > 0 && coinToast) {
        drawPopText(coinToast, coinToastTime, 0.9, 118, '#22c55e');
      }

      if (missionToastTime > 0 && missionToast) {
        drawPopText(missionToast, missionToastTime, 1.1, 152, '#fbbf24');
      }

      // Checkpoint flash
      if (checkpointFlashTime > 0) {
        checkpointFlashTime -= Math.min(checkpointFlashTime, 1/60);
        ctx.save();
        ctx.globalAlpha = Math.min(1, checkpointFlashTime / 1.2 * 1.5);
        ctx.fillStyle = '#22c55e';
        ctx.textAlign = 'center';
        ctx.font = 'bold 26px sans-serif';
        ctx.fillText('Checkpoint saved!', canvas.width/2, 80);
        ctx.restore();
      }

      if (screen === 'play' && settingsOpen) {
        const sb = getSettingsButtons();
        drawPanel(sb.panel.x, sb.panel.y, sb.panel.w, sb.panel.h);

        ctx.save();
        ctx.fillStyle = '#111';
        ctx.textAlign = 'left';
        ctx.font = 'bold 20px sans-serif';
        ctx.fillText('Settings', sb.panel.x + 24, sb.panel.y + 42);

        ctx.font = '16px sans-serif';
        ctx.fillText('SFX Volume', sb.panel.x + 24, sb.panel.y + 92);
        ctx.fillText(`${Math.round(sfxVolume * 100)}%`, sb.panel.x + 24 + 210 + 54 + 10 + 54 + 14, sb.panel.y + 92);

        const drawBtn = (b, text, active = false) => {
          ctx.save();
          ctx.globalAlpha = 0.92;
          roundRectPath(b.x, b.y, b.w, b.h, 10);
          ctx.fillStyle = active ? 'rgba(34,197,94,0.78)' : 'rgba(255,255,255,0.78)';
          ctx.fill();
          ctx.globalAlpha = 0.35;
          ctx.strokeStyle = 'rgba(0,0,0,0.35)';
          ctx.lineWidth = 1;
          ctx.stroke();
          ctx.globalAlpha = 1;
          ctx.fillStyle = '#111';
          ctx.textAlign = 'center';
          ctx.font = 'bold 14px sans-serif';
          ctx.fillText(text, b.x + b.w * 0.5, b.y + 22);
          ctx.restore();
        };

        drawBtn(sb.volMinus, '-');
        drawBtn(sb.volPlus, '+');

        ctx.fillStyle = '#111';
        ctx.textAlign = 'left';
        ctx.font = '16px sans-serif';
        ctx.fillText('Screen Shake', sb.panel.x + 24, sb.panel.y + 146);
        drawBtn(sb.shakeToggle, shakeEnabled ? 'ON' : 'OFF', shakeEnabled);

        ctx.fillText('Particles', sb.panel.x + 24, sb.panel.y + 200);
        drawBtn(sb.particlesToggle, particlesEnabled ? 'ON' : 'OFF', particlesEnabled);

        drawBtn(sb.close, 'CLOSE');
        ctx.restore();
      }

      if (gameOver && deathTimer >= deathDuration && screen === 'play') {
        if (!bestSaved && noCheckpointsMode) {
          const dist = Math.floor(maxReachedX);
          if (score > bestScore) bestScore = score;
          if (dist > bestDistance) bestDistance = dist;
          try {
            localStorage.setItem(BEST_SCORE_KEY, String(bestScore));
            localStorage.setItem(BEST_DISTANCE_KEY, String(bestDistance));
          } catch (e) {}
          bestSaved = true;
        }
        ctx.fillStyle = 'rgba(0,0,0,0.5)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#fff';
        ctx.textAlign = 'center';
        ctx.font = '28px sans-serif';
        ctx.fillText('You fell or hit spikes!', canvas.width/2, canvas.height/2 - 10);
        ctx.font = '20px sans-serif';
        ctx.fillText(noCheckpointsMode ? 'Press R to restart run' : 'Press R to respawn at last checkpoint', canvas.width/2, canvas.height/2 + 24);
        ctx.font = '18px sans-serif';
        const earned = coins - runStartCoins;
        ctx.fillText(`Distance: ${Math.floor(maxReachedX)} px   Score: ${score}`, canvas.width/2, canvas.height/2 + 52);
        ctx.fillText(`Coins earned: ${earned}   Deaths: ${deathsThisRun}`, canvas.width/2, canvas.height/2 + 76);
        if (noCheckpointsMode) {
          ctx.fillText(`Best Distance: ${bestDistance} px   Best Score: ${bestScore}`, canvas.width/2, canvas.height/2 + 100);
        }
        ctx.textAlign = 'left';
      }

      ctx.restore();

      drawVignette();
    }

    let last = performance.now();
    function loop(ts) {
      const dt = Math.min(1/30, (ts - last) / 1000);
      last = ts;

      const escapePressed = keys.has('escape');
      const escapeEdge = escapePressed && !escapeHeld;
      escapeHeld = escapePressed;
      if (escapeEdge) {
        if (screen === 'play') enterMenu();
      }
      if (keys.has('r')) {
        if (screen === 'play') {
          if (!gameOver || deathTimer >= deathDuration) {
            if (keys.has('shift')) {
              hardReset();
            } else {
              if (noCheckpointsMode) hardReset(); else respawnAtCheckpoint();
            }
          }
        }
      }
      update(dt);
      draw();
      requestAnimationFrame(loop);
    }
    if (screen === 'menu') enterMenu();
    else hardReset();
    requestAnimationFrame(loop);
  </script>
</body>
</html>