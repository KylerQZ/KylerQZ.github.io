<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Racing Game</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a1a 50%, #000000 100%);
            font-family: 'Arial', sans-serif;
            color: #d4af37;
            overflow: hidden;
        }
        
        #gameContainer {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            padding: 20px;
        }
        
        #canvas {
            border: 3px solid #d4af37;
            box-shadow: 0 0 30px rgba(255, 202, 27, 0.5);
            border-radius: 8px;
            background: #000;
        }
        
        #ui {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(26, 26, 26, 0.9);
            border: 2px solid rgba(235, 181, 7, 0.5);
            border-radius: 8px;
            padding: 15px;
            min-width: 200px;
        }
        
        #ui h3 {
            margin: 0 0 10px 0;
            color: #d4af37;
            font-size: 18px;
        }
        
        .stat {
            display: flex;
            justify-content: space-between;
            margin: 8px 0;
            color: #cccccc;
        }
        
        .stat-label {
            font-weight: bold;
            color: #d4af37;
        }
        
        .stat-value {
            color: #ffffff;
        }
        
        #controls {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(26, 26, 26, 0.9);
            border: 2px solid rgba(212, 175, 55, 0.5);
            border-radius: 8px;
            padding: 15px;
        }
        
        #controls h4 {
            margin: 0 0 10px 0;
            color: #d4af37;
        }
        
        #controls ul {
            margin: 0;
            padding-left: 20px;
            color: #cccccc;
        }
        
        #controls li {
            margin: 5px 0;
        }
        
        .key {
            background: #d4af37;
            color: #000;
            padding: 2px 6px;
            border-radius: 3px;
            font-weight: bold;
            font-family: monospace;
        }
        
        #backButton {
            position: fixed;
            top: 20px;
            right: 20px;
            background: #d4af37;
            color: #000;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.2s ease;
            box-shadow: 0 4px 12px rgba(212, 175, 55, 0.3);
        }
        
        #backButton:hover {
            background: #b8941f;
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(212, 175, 55, 0.5);
        }
        
        #loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(26, 26, 26, 0.95);
            border: 2px solid #d4af37;
            border-radius: 12px;
            padding: 30px 50px;
            text-align: center;
            font-size: 20px;
            color: #d4af37;
            z-index: 1000;
        }
    </style>
</head>
<body>
    <div id="loading">Loading Racing Game...</div>
    
    <button id="backButton" onclick="window.location.href='../../games.html'">üè† Back to Games</button>
    
    <div id="ui">
        <h3>üèéÔ∏è Car Stats</h3>
        <div class="stat">
            <span class="stat-label">Speed:</span>
            <span class="stat-value" id="speed">0</span>
        </div>
        <div class="stat">
            <span class="stat-label">Position:</span>
            <span class="stat-value" id="position">0, 0</span>
        </div>
        <div class="stat">
            <span class="stat-label">Rotation:</span>
            <span class="stat-value" id="rotation">0¬∞</span>
        </div>
    </div>
    
    <div id="controls">
        <h4>‚å®Ô∏è Controls</h4>
        <ul>
            <li><span class="key">W</span> / <span class="key">‚Üë</span> - Accelerate</li>
            <li><span class="key">S</span> / <span class="key">‚Üì</span> - Brake/Reverse</li>
            <li><span class="key">A</span> / <span class="key">‚Üê</span> - Turn Left</li>
            <li><span class="key">D</span> / <span class="key">‚Üí</span> - Turn Right</li>
            <li><span class="key">E</span> - Drift Mode (Hold)</li>
        </ul>
    </div>
    
    <div id="gameContainer">
        <canvas id="canvas" width="1200" height="800"></canvas>
    </div>
    
    <script>
        // This will be replaced with the compiled WebAssembly module
        // For now, this is a placeholder showing how the integration works
        
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        // Temporary JavaScript version for testing before WASM compilation
        let car = {
            x: 600,
            y: 400,
            rotation: 0,
            speed: 0,
            width: 40,
            height: 80
        };
        
        const keys = {};
        // Speed scaling: 1 km/h = 1 internal unit (scaled down from C++ for JS performance)
        const SPEED_SCALE = 1; // 1 km/h = 1 unit in JS
        const MAX_SPEED_KMH = 200; // Maximum speed in km/h
        const MAX_SPEED = MAX_SPEED_KMH * SPEED_SCALE; // 200 units
        const ACCELERATION = 5; // Much faster acceleration
        const TURN_SPEED = 0.05;
        const FRICTION = 0.98;
        const WORLD_SIZE = 2000; // Larger map
        const BOUNCE_THRESHOLD = 80; // Speed threshold for bounce
        const DRIFT_THRESHOLD = 100; // 100 km/h
        
        // Particle system for smoke
        const particles = [];
        const MAX_PARTICLES = 100;
        
        class Particle {
            constructor(x, y) {
                this.x = x + (Math.random() - 0.5) * 10;
                this.y = y + (Math.random() - 0.5) * 10;
                this.vx = (Math.random() - 0.5) * 2;
                this.vy = (Math.random() - 0.5) * 2;
                this.life = 1.0;
                this.size = 5 + Math.random() * 10;
                this.alpha = 0.6;
            }
            
            update(dt) {
                this.x += this.vx;
                this.y += this.vy;
                this.life -= dt * 0.5;
                this.alpha = this.life * 0.6;
                this.size += dt * 10;
            }
            
            draw(ctx) {
                if (this.life > 0) {
                    ctx.save();
                    ctx.globalAlpha = this.alpha;
                    const gray = Math.floor(128 + this.life * 50);
                    ctx.fillStyle = `rgb(${gray}, ${gray}, ${gray})`;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                }
            }
        }
        
        // Camera offset for larger world
        let cameraX = 0;
        let cameraY = 0;
        
        window.addEventListener('keydown', (e) => {
            keys[e.key.toLowerCase()] = true;
            // Also handle arrow keys
            if (e.key === 'ArrowUp') keys['w'] = true;
            if (e.key === 'ArrowDown') keys['s'] = true;
            if (e.key === 'ArrowLeft') keys['a'] = true;
            if (e.key === 'ArrowRight') keys['d'] = true;
        });
        
        window.addEventListener('keyup', (e) => {
            keys[e.key.toLowerCase()] = false;
            // Also handle arrow keys
            if (e.key === 'ArrowUp') keys['w'] = false;
            if (e.key === 'ArrowDown') keys['s'] = false;
            if (e.key === 'ArrowLeft') keys['a'] = false;
            if (e.key === 'ArrowRight') keys['d'] = false;
        });
        
        function updateCar() {
            // Acceleration
            if (keys['w']) {
                car.speed += ACCELERATION;
            } else if (keys['s']) {
                car.speed -= ACCELERATION;
            }
            
            // Clamp speed
            car.speed = Math.max(-MAX_SPEED * 0.5, Math.min(MAX_SPEED, car.speed));
            
            // Steering with manual drift control
            if (Math.abs(car.speed) > 0.1) {
                const turnFactor = car.speed / MAX_SPEED;
                // Manual drift mode - only drift when E is pressed
                const isDrifting = keys['e'] && Math.abs(car.speed) > DRIFT_THRESHOLD;
                const driftMultiplier = isDrifting ? 1.8 : 1.0;
                
                let steerInput = 0;
                if (keys['a']) {
                    steerInput = -TURN_SPEED * turnFactor * driftMultiplier;
                    car.rotation += steerInput;
                }
                if (keys['d']) {
                    steerInput = TURN_SPEED * turnFactor * driftMultiplier;
                    car.rotation += steerInput;
                }
                
                // Drift/slide effect when E key is pressed and speed is high
                if (isDrifting && Math.abs(steerInput) > 0.001) {
                    const driftAmount = Math.min((Math.abs(car.speed) - DRIFT_THRESHOLD) / DRIFT_THRESHOLD, 1.0);
                    
                    // Add lateral slide perpendicular to car direction
                    const slideX = Math.cos(car.rotation) * steerInput * driftAmount * 4;
                    const slideY = -Math.sin(car.rotation) * steerInput * driftAmount * 4;
                    
                    car.x += slideX;
                    car.y += slideY;
                }
            }
            
            // Apply friction
            car.speed *= FRICTION;
            
            // Update position
            car.x += Math.sin(car.rotation) * car.speed;
            car.y -= Math.cos(car.rotation) * car.speed;
            
            // Border collision with bounce
            if (car.x > WORLD_SIZE || car.x < -WORLD_SIZE) {
                if (Math.abs(car.speed) > BOUNCE_THRESHOLD) {
                    car.speed = -car.speed * 0.6;
                } else {
                    car.speed = 0;
                }
                car.x = Math.max(-WORLD_SIZE, Math.min(WORLD_SIZE, car.x));
            }
            
            if (car.y > WORLD_SIZE || car.y < -WORLD_SIZE) {
                if (Math.abs(car.speed) > BOUNCE_THRESHOLD) {
                    car.speed = -car.speed * 0.6;
                } else {
                    car.speed = 0;
                }
                car.y = Math.max(-WORLD_SIZE, Math.min(WORLD_SIZE, car.y));
            }
            
            // Update camera to follow car
            cameraX = car.x - canvas.width / 2;
            cameraY = car.y - canvas.height / 2;
            
            // Update UI
            const speedKmh = Math.abs(car.speed / SPEED_SCALE); // Convert to km/h
            document.getElementById('speed').textContent = speedKmh.toFixed(1) + ' km/h';
            document.getElementById('position').textContent = `${car.x.toFixed(0)}, ${car.y.toFixed(0)}`;
            document.getElementById('rotation').textContent = (car.rotation * 180 / Math.PI).toFixed(0) + '¬∞';
        }
        
        function drawCar() {
            ctx.save();
            ctx.translate(car.x - cameraX, car.y - cameraY);
            ctx.rotate(car.rotation);
            
            // Main body - metallic red
            ctx.fillStyle = '#cc1a1a';
            ctx.fillRect(-car.width/2, -car.height/2, car.width, car.height * 0.6);
            
            // Cabin/roof - darker red
            ctx.fillStyle = '#991515';
            ctx.fillRect(-car.width * 0.4, -car.height * 0.3, car.width * 0.8, car.height * 0.4);
            
            // Windshield - dark blue
            ctx.fillStyle = '#1a1a33';
            ctx.fillRect(-car.width * 0.35, -car.height * 0.25, car.width * 0.7, car.height * 0.15);
            
            // Wheels - black
            ctx.fillStyle = '#1a1a1a';
            const wheelSize = 8;
            ctx.fillRect(-car.width/2 - wheelSize, -car.height/2 + 10, wheelSize, 15);
            ctx.fillRect(car.width/2, -car.height/2 + 10, wheelSize, 15);
            ctx.fillRect(-car.width/2 - wheelSize, car.height/2 - 25, wheelSize, 15);
            ctx.fillRect(car.width/2, car.height/2 - 25, wheelSize, 15);
            
            // Headlights - yellow
            ctx.fillStyle = '#ffff66';
            ctx.fillRect(-car.width/2 + 5, -car.height/2, 8, 4);
            ctx.fillRect(car.width/2 - 13, -car.height/2, 8, 4);
            
            // Tail lights - red
            ctx.fillStyle = '#ff0000';
            ctx.fillRect(-car.width/2 + 5, car.height/2 - 4, 8, 4);
            ctx.fillRect(car.width/2 - 13, car.height/2 - 4, 8, 4);
            
            // Spoiler
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(-car.width * 0.4, car.height/2 - 8, car.width * 0.8, 3);
            
            ctx.restore();
        }
        
        function drawTerrain() {
            // Base ground - clean asphalt
            ctx.fillStyle = '#5a5a5a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Grid lines for depth
            ctx.strokeStyle = '#6a6a6a';
            ctx.lineWidth = 1;
            const gridSize = 50;
            
            // Calculate visible grid range
            const startX = Math.floor(cameraX / gridSize) * gridSize;
            const startY = Math.floor(cameraY / gridSize) * gridSize;
            
            for (let x = startX; x < cameraX + canvas.width; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x - cameraX, 0);
                ctx.lineTo(x - cameraX, canvas.height);
                ctx.stroke();
            }
            
            for (let y = startY; y < cameraY + canvas.height; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(0, y - cameraY);
                ctx.lineTo(canvas.width, y - cameraY);
                ctx.stroke();
            }
            
            // Draw border walls
            const wallHeight = 20;
            
            // Check if borders are visible
            if (WORLD_SIZE - cameraX < canvas.width) {
                // Right wall
                for (let y = -WORLD_SIZE; y < WORLD_SIZE; y += 100) {
                    const screenY = y - cameraY;
                    if (screenY > -100 && screenY < canvas.height + 100) {
                        ctx.fillStyle = (Math.floor(y / 100) % 2 === 0) ? '#ff0000' : '#ffffff';
                        ctx.fillRect(WORLD_SIZE - cameraX, screenY, 10, 100);
                    }
                }
            }
            
            if (-WORLD_SIZE - cameraX > -10) {
                // Left wall
                for (let y = -WORLD_SIZE; y < WORLD_SIZE; y += 100) {
                    const screenY = y - cameraY;
                    if (screenY > -100 && screenY < canvas.height + 100) {
                        ctx.fillStyle = (Math.floor(y / 100) % 2 === 0) ? '#ff0000' : '#ffffff';
                        ctx.fillRect(-WORLD_SIZE - cameraX, screenY, 10, 100);
                    }
                }
            }
            
            if (WORLD_SIZE - cameraY < canvas.height) {
                // Bottom wall
                for (let x = -WORLD_SIZE; x < WORLD_SIZE; x += 100) {
                    const screenX = x - cameraX;
                    if (screenX > -100 && screenX < canvas.width + 100) {
                        ctx.fillStyle = (Math.floor(x / 100) % 2 === 0) ? '#ff0000' : '#ffffff';
                        ctx.fillRect(screenX, WORLD_SIZE - cameraY, 100, 10);
                    }
                }
            }
            
            if (-WORLD_SIZE - cameraY > -10) {
                // Top wall
                for (let x = -WORLD_SIZE; x < WORLD_SIZE; x += 100) {
                    const screenX = x - cameraX;
                    if (screenX > -100 && screenX < canvas.width + 100) {
                        ctx.fillStyle = (Math.floor(x / 100) % 2 === 0) ? '#ff0000' : '#ffffff';
                        ctx.fillRect(screenX, -WORLD_SIZE - cameraY, 100, 10);
                    }
                }
            }
        }
        
        function updateParticles(dt) {
            // Update existing particles
            for (let i = particles.length - 1; i >= 0; i--) {
                particles[i].update(dt);
                if (particles[i].life <= 0) {
                    particles.splice(i, 1);
                }
            }
            
            // Spawn new smoke particles when car is moving
            if (Math.abs(car.speed) > 0.5) {
                if (particles.length < MAX_PARTICLES && Math.random() < 0.3) {
                    // Spawn from rear of car
                    const rearX = car.x - Math.sin(car.rotation) * car.height * 0.3;
                    const rearY = car.y - Math.cos(car.rotation) * car.height * 0.3;
                    particles.push(new Particle(rearX, rearY));
                }
            }
        }
        
        function drawParticles() {
            particles.forEach(p => {
                ctx.save();
                ctx.translate(-cameraX, -cameraY);
                p.draw(ctx);
                ctx.restore();
            });
        }
        
        function gameLoop() {
            // Draw terrain
            drawTerrain();
            
            // Update particles
            updateParticles(0.016);
            
            // Draw particles behind car
            drawParticles();
            
            // Update and draw car
            updateCar();
            drawCar();
            
            requestAnimationFrame(gameLoop);
        }
        
        // Hide loading screen and start game
        document.getElementById('loading').style.display = 'none';
        gameLoop();
        
        console.log('üèéÔ∏è Racing Game Started!');
        console.log('Note: This is a JavaScript placeholder. Compile game.cpp to WebAssembly for the full C++ version.');
    </script>
</body>
</html>
